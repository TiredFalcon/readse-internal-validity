[{"_id":"5eb233fadeb70a6af22379bf","documentRepoId":"5eb233e4deb70a6af2233f56","documentRepoName":"research-bin-saner2019-era","fkglDelta":2.368135326514558,"freDelta":0.832690794649892,"from":{"commitAuthorEmail":"csaba.nagy@usi.ch","commitId":"5eb233ebdeb70a6af22348f6","readability":{"daleChallScore":12.81442258064516,"fleschKincaidGradeLevel":20.480645161290322,"fleschReadingEase":3.440967741935509,"papersDomainScore":8.230229032258066},"text":"After obtaining all the commits with refactoring operations, we filtered out commits involved in more than one refactoring type, to avoid the impact of irrelevant refactorings when assessing the naturalness change."},"to":{"commitAuthorEmail":"gabriele.bavota@gmail.com","commitId":"5eb233ecdeb70a6af2234a07","readability":{"daleChallScore":12.217173170731707,"fleschKincaidGradeLevel":22.84878048780488,"fleschReadingEase":4.273658536585401,"papersDomainScore":7.980831707317073},"text":"After obtaining all the commits with refactoring operations, we filtered out commits involved in which more than one refactoring type was applied, again to better isolate and study the effect of a single type of refactoring operation on the code naturalness."}},{"_id":"5eb233fadeb70a6af2237957","documentRepoId":"5eb233e4deb70a6af2233f56","documentRepoName":"research-bin-saner2019-era","fkglDelta":2.272092391304346,"freDelta":-15.102346014492781,"from":{"commitAuthorEmail":"michele.lanza@usi.ch","commitId":"5eb233f0deb70a6af22354c7","readability":{"daleChallScore":10.575728985507245,"fleschKincaidGradeLevel":11.424782608695654,"fleschReadingEase":40.46297101449278,"papersDomainScore":8.85942463768116},"text":"Threats to construct validity concern the relation between theory and observation. In this work, we use RMiner{.smallcaps} to detect refactorings. While the precision achieved by this tool is very high, we are aware that our results can be affected by the presence of false positives."},"to":{"commitAuthorEmail":"csaba.nagy@unamur.be","commitId":"5eb233f1deb70a6af2235617","readability":{"daleChallScore":11.09150625,"fleschKincaidGradeLevel":13.696875,"fleschReadingEase":25.360625,"papersDomainScore":8.62431875},"text":"Threats to construct validity concern the relation between theory and observation. In this work, we use RMiner{.smallcaps} to detect refactorings. While the precision achieved by this tool is very high, we are aware that our results can be affected by the presence of false positives. Also, RMiner{.smallcaps} can identify a specific set of refactoring operations, while the definition of refactoring is broader."}},{"_id":"5eb233fadeb70a6af2237903","documentRepoId":"5eb233e4deb70a6af2233f56","documentRepoName":"research-bin-saner2019-era","fkglDelta":2.95301291989664,"freDelta":-19.03427906976745,"from":{"commitAuthorEmail":"csaba.nagy@usi.ch","commitId":"5eb233e9deb70a6af2234337","readability":{"daleChallScore":11.64835054263566,"fleschKincaidGradeLevel":16.242542635658918,"fleschReadingEase":24.56427906976748,"papersDomainScore":7.8538544186046515},"text":"During software development, developers often perform refactoring operations to enhance the maintainability of source code as low-quality code usually leads to more changes and faults in the software. One interesting question here is whether refactoring is a process of improving the naturalness of source code. Intuitively, we might think the source code is easier to maintain if it is more natural, as there are much fewer \"surprising\" and \"unfamiliar\" code fragments for developers. In fact, that researchers have already disclosed that buggy code is less natural and managed to support bug localization by analyzing the code naturalness. If we can also find such type of relation between code naturalness and refactored code, we might be able to indicate which part of the code is more likely to need refactoring."},"to":{"commitAuthorEmail":"gabriele.bavota@gmail.com","commitId":"5eb233e9deb70a6af223439a","readability":{"daleChallScore":12.870700000000001,"fleschKincaidGradeLevel":19.195555555555558,"fleschReadingEase":5.53000000000003,"papersDomainScore":8.484588888888888},"text":"One interesting unanswered question is whether software refactoring (i.e., the activity of improving code quality without modifying the system's external behavior) can be seen as a process implicitly aimed at improving the naturalness of source code. Intuitively, we might think the source code is easier to maintain if it is more natural, as there are fewer \"surprising\" and \"unfamiliar\" code fragments for developers. Thus, it can be conjectured that developers focus their refactoring attentions on code exhibiting a low naturalness. If such a conjecture is confirmed, information about the naturalness of code components could be leveraged to support refactoring operations (e.g., by identifying code components in need of refactoring)."}},{"_id":"5eb233fadeb70a6af223796d","documentRepoId":"5eb233e4deb70a6af2233f56","documentRepoName":"research-bin-saner2019-era","fkglDelta":2.669679278901585,"freDelta":-10.74362068965516,"from":{"commitAuthorEmail":"b.lin@live.com","commitId":"5eb233eddeb70a6af2234bcc","readability":{"daleChallScore":9.4509757852077,"fleschKincaidGradeLevel":13.271388044579535,"fleschReadingEase":35.79000000000002,"papersDomainScore":6.987287841945289},"text":"In our study, only 49.7% of the total refactorings increase the code naturalness, which is much higher in their case (67.9%). The reason behind this can be resulted by the datasets. First of all, since their dataset is very small, the difference might simply be a bias. Second, in their study, they only adopted one well-known project -- JUnit 4, while in our study, we did not consider the quality of projects. Since JUnit 4 has a huge community and is well-maintained, therefore, the refactorings might have better quality, thus resulting more naturalness increases than the projects used in our dataset. Of course, this is only an assumption, which needs to be verified carefully. However, this assumption also indicates a direction to work with: we might need to better understand the association between code quality and naturalness, which is not fully disclosed in the research community."},"to":{"commitAuthorEmail":"gabriele.bavota@gmail.com","commitId":"5eb233eddeb70a6af2234d71","readability":{"daleChallScore":10.677230377668309,"fleschKincaidGradeLevel":15.94106732348112,"fleschReadingEase":25.04637931034486,"papersDomainScore":7.86406945812808},"text":"In our study, only 49.7% of the total refactorings increase the code naturalness, which is much lower than what has been observed in (67.9%). The reason behind this different finding could be explained by the different datasets employed in the two studies. First, the dataset used in is composed by only XX refactorings (as compared to the 1,305 considered in our study), thus possibly indicating peculiarities of the specific refactoring operations considered. Second, the XX refactorings used in have all been mined from a single, well-known project, namely JUnit 4, while in our study we extracted the studied refactorings from a variegate set of XX projects. It is possible that the \"quality\" of the refactorings applied in JUnit 4 is higher, thus resulting in a naturalness increase that we did not observe in our dataset. Clearly, this is only an assumption, which needs to be carefully verified. However, this assumption also indicates a direction to work with: We might need to better understand the association between code quality and naturalness, which is not fully disclosed in the research community."}},{"_id":"5eb233fadeb70a6af2237a20","documentRepoId":"5eb233e4deb70a6af2233f56","documentRepoName":"research-bin-saner2019-era","fkglDelta":5.933030303030302,"freDelta":-36.3029545454545,"from":{"commitAuthorEmail":"csaba.nagy@usi.ch","commitId":"5eb233ebdeb70a6af22348f6","readability":{"daleChallScore":10.196718181818182,"fleschKincaidGradeLevel":11.941969696969698,"fleschReadingEase":38.832954545454555,"papersDomainScore":5.4118696969696956},"text":"Our goal is to understand whether refactoring can improve the naturalness of code. For this reason, here we assess how the code naturalness is impacted by both overall and specific types of refactorings."},"to":{"commitAuthorEmail":"gabriele.bavota@gmail.com","commitId":"5eb233ecdeb70a6af2234a07","readability":{"daleChallScore":12.918250000000002,"fleschKincaidGradeLevel":17.875,"fleschReadingEase":2.530000000000058,"papersDomainScore":6.60225},"text":"Our goal is to investigate whether refactoring operations increase the naturalness of the refactored code. We assess how the code naturalness is impacted (i) overall, meaning when considering all types of refactoring operations together, and (ii) by specific types of refactoring."}},{"_id":"5eb233fadeb70a6af2237917","documentRepoId":"5eb233e4deb70a6af2233f56","documentRepoName":"research-bin-saner2019-era","fkglDelta":1.8356549707602383,"freDelta":-6.392526315789496,"from":{"commitAuthorEmail":"gabriele.bavota@gmail.com","commitId":"5eb233e9deb70a6af223448b","readability":{"daleChallScore":12.727695263157894,"fleschKincaidGradeLevel":19.78836842105263,"fleschReadingEase":7.335578947368447,"papersDomainScore":8.053024210526317},"text":"The most relevant work is the empirical study conducted by Arima et al., which uses the code naturalness as a metric to evaluate whether a refactoring operation is effective. With the assumption that appropriate refactoring should raise the naturalness of code, the authors examined 28 refactoring operations extracted from JUnit4^1 by searching for the keywords \"refactor\" and \"clean\" in commit logs and manually filtering out those commits containing more than one refactoring. As a result, 19 out of the 28 refactorings have been used in the study. Our study, while having a similar objective (i.e., studying the impact of refactoring operations on code naturalness) is performed on a much larger dataset composed of XXX refactorings extracted from XX systems. Also, we investigate the impact of refactoring operations on the code naturalness by considering the type of implemented refactoring (e.g., move method) as an independent variable to study (possibly having an effect on the \"naturalness\" dependent variable)."},"to":{"commitAuthorEmail":"b.lin@live.com","commitId":"5eb233eadeb70a6af223455e","readability":{"daleChallScore":13.089311228070175,"fleschKincaidGradeLevel":21.62402339181287,"fleschReadingEase":0.9430526315789507,"papersDomainScore":8.47235216374269},"text":"The most relevant work is the empirical study conducted by Arima et al., which uses the code naturalness as a metric to evaluate whether a refactoring operation is effective. With the assumption that appropriate refactoring should raise the naturalness of code, the authors constructed a gold set of 28 refactoring operations extracted from JUnit4^1 by searching for the keywords \"refactor\" and \"clean\" in commit logs and manually filtering out those commits containing more than one refactoring. As a result, the code naturalness increases after 19 out of the 28 refactorings, which indicates that naturalness might be a potential valid metric for evaluating the quality of refactoring. Our study, while having a similar objective (i.e., studying the impact of refactoring operations on code naturalness) is performed on a much larger dataset composed of XXX refactorings extracted from XX systems. Also, we investigate the impact of refactoring operations on the code naturalness by considering the type of implemented refactoring (e.g., move method) as an independent variable to study (possibly having an effect on the \"naturalness\" dependent variable)."}},{"_id":"5eb233fadeb70a6af2237939","documentRepoId":"5eb233e4deb70a6af2233f56","documentRepoName":"research-bin-saner2019-era","fkglDelta":-3.728780487804876,"freDelta":7.141341463414619,"from":{"commitAuthorEmail":"gabriele.bavota@gmail.com","commitId":"5eb233eddeb70a6af2234d71","readability":{"daleChallScore":12.217173170731707,"fleschKincaidGradeLevel":22.84878048780488,"fleschReadingEase":4.273658536585401,"papersDomainScore":7.980831707317073},"text":"After obtaining all the commits with refactoring operations, we filtered out commits involved in which more than one refactoring type was applied, again to better isolate and study the effect of a single type of refactoring operation on the code naturalness."},"to":{"commitAuthorEmail":"b.lin@live.com","commitId":"5eb233eedeb70a6af2234f10","readability":{"daleChallScore":11.703666666666667,"fleschKincaidGradeLevel":19.120000000000005,"fleschReadingEase":11.41500000000002,"papersDomainScore":7.229833333333333},"text":"After obtaining all the commits with refactoring operations, we filtered out commits involved in which more than one refactoring type was applied, again to better isolate and study the effect of a single type of refactoring operation on the code naturalness. In the end, we obtained 1,448 refactoring operations from 619 projects, while no relevant refactorings are detected in the other 881 projects."}},{"_id":"5eb233fadeb70a6af223789e","documentRepoId":"5eb233e4deb70a6af2233f56","documentRepoName":"research-bin-saner2019-era","fkglDelta":5.387654135338341,"freDelta":-15.014421052631548,"from":{"commitAuthorEmail":"gabriele.bavota@gmail.com","commitId":"5eb233e9deb70a6af223439a","readability":{"daleChallScore":11.46070238095238,"fleschKincaidGradeLevel":14.40071428571429,"fleschReadingEase":22.349999999999994,"papersDomainScore":7.250035714285715},"text":"The most relevant work is a empirical study conducted by Arima et al., which uses the code naturalness as a metric to evaluate whether a refactoring operation is good. With the assumption that appropriate should raise the naturalness of code, the authors examined 28 refactorings. These refactorings are extracted from JUnit4^1 by searching \"refactor\" and \"clean\" in commit logs and manually filtering out those commits containing more than one refactoring. As a result, 19 out of the 28 refactorings are considered appropriate by the naturalness metric. The generability is the major limitation of this study. Only one project and 28 refactorings are considered, thus not guaranteeing naturalness can be still valid for other refactorings. Also, the impact of the refactoring types is not investigated."},"to":{"commitAuthorEmail":"gabriele.bavota@gmail.com","commitId":"5eb233e9deb70a6af223448b","readability":{"daleChallScore":12.727695263157894,"fleschKincaidGradeLevel":19.78836842105263,"fleschReadingEase":7.335578947368447,"papersDomainScore":8.053024210526317},"text":"The most relevant work is the empirical study conducted by Arima et al., which uses the code naturalness as a metric to evaluate whether a refactoring operation is effective. With the assumption that appropriate refactoring should raise the naturalness of code, the authors examined 28 refactoring operations extracted from JUnit4^1 by searching for the keywords \"refactor\" and \"clean\" in commit logs and manually filtering out those commits containing more than one refactoring. As a result, 19 out of the 28 refactorings have been used in the study. Our study, while having a similar objective (i.e., studying the impact of refactoring operations on code naturalness) is performed on a much larger dataset composed of XXX refactorings extracted from XX systems. Also, we investigate the impact of refactoring operations on the code naturalness by considering the type of implemented refactoring (e.g., move method) as an independent variable to study (possibly having an effect on the \"naturalness\" dependent variable)."}},{"_id":"5eb233fadeb70a6af22379b6","documentRepoId":"5eb233e4deb70a6af2233f56","documentRepoName":"research-bin-saner2019-era","fkglDelta":-4.361877380554628,"freDelta":15.776858169061171,"from":{"commitAuthorEmail":"b.lin@live.com","commitId":"5eb233e7deb70a6af2234022","readability":{"daleChallScore":12.65536794520548,"fleschKincaidGradeLevel":21.014438356164383,"fleschReadingEase":-3.5920410958904085,"papersDomainScore":8.004888493150684},"text":"*abstract*: Recent studies have demonstrated that software is natural, that is, its source code is highly repetitive and predictable like human languages. This characteristic has been leveraged to support many software development activities, such as code completion and defect prediction. Given the promising results achieved in this area, one might wonder if refactoring operations have a positive effect on the naturalness of the source code, or whether the naturalness information can be useful for locating refactoring opportunities. With the ultimate goal of supporting refactoring activities leveraging the naturalness information, in this paper, we take the first step to investigate whether refactoring operations indeed improve the naturalness of refactored code. With a large amount of refactoring operations inspected, we observed a different effect on naturalness change for different refactoring types, and interestingly, we found that code refactoring does not necessarily increase the naturalness of the refactored code."},"to":{"commitAuthorEmail":"gabriele.bavota@gmail.com","commitId":"5eb233e7deb70a6af223404a","readability":{"daleChallScore":12.452019512195122,"fleschKincaidGradeLevel":16.652560975609756,"fleschReadingEase":12.184817073170763,"papersDomainScore":7.7342756097560965},"text":"*abstract*: Recent studies have demonstrated that software is natural, that is, its source code is highly repetitive and predictable like human languages. Also, previous studies suggested the existence of a relationship between code quality and its naturalness, presenting empirical evidence showing that buggy code is \"less natural\" than non-buggy code. In this paper, we investigate this quality-naturalness relationship from a different perspective: We analyze if refactoring can improve the naturalness of code. The ultimate goal is to verify whether naturalness information could be used, in future, to support refactoring activities (*e.g.,* to locate source code areas in need of refactoring). We started by using state-of-the-art tools to mine a large dataset of refactoring operations performed in open source systems. Then, we investigate the impact of different types of refactoring operations on the naturalness of the impacted code. We found that (i) code refactoring does not necessarily increase the naturalness of the refactored code; and (ii) different refactoring operations have a different impact on the code naturalness."}},{"_id":"5eb233fadeb70a6af2237a94","documentRepoId":"5eb233e4deb70a6af2233f56","documentRepoName":"research-bin-saner2019-era","fkglDelta":-3.189189189189186,"freDelta":22.864864864864842,"from":{"commitAuthorEmail":"b.lin@live.com","commitId":"5eb233f5deb70a6af223621a","readability":{"daleChallScore":15.713862162162163,"fleschKincaidGradeLevel":23.077837837837837,"fleschReadingEase":-4.49297297297295,"papersDomainScore":10.166024324324324},"text":"::: {#tab:statistics}\n| Refactoring type    |  P-Value| Effect Size    |\n|:------------------------|------------:|:-------------------|\n| Extract Method          |        0.444| 0.004 (negligible) |\n| Inline Method           |        0.414| 0.018 (negligible) |\n| Pull Up Method          |        0.010| 0.482 (large)      |\n| Rename Method           |        0.484| 0.001 (negligible) |\n| Move Method             |        0.360| 0.033 (negligible) |\n| Extract and Move Method |        0.260| 0.035 (negligible) |\n| Pull Up Field           |        0.346| 0.165 (small)      |\n| Move Field              |        0.431| 0.009 (negligible) |\n| Overall                 |        0.444| 0.004 (negligible) |."},"to":{"commitAuthorEmail":"b.lin@live.com","commitId":"5eb233f5deb70a6af22364f3","readability":{"daleChallScore":14.433591891891892,"fleschKincaidGradeLevel":19.88864864864865,"fleschReadingEase":18.37189189189189,"papersDomainScore":8.885754054054054},"text":"::: {#tab:statistics}\n| Refactoring type    |  P-Value| Effect Size    |\n|:------------------------|------------:|:-------------------|\n| Extract Method          |     < 0.001| 0.180 (small)      |\n| Inline Method           |        0.202| 0.119 (small)      |\n| Pull Up Method          |     < 0.001| 0.414 (medium)     |\n| Rename Method           |        0.177| 0.044 (negligible) |\n| Move Method             |        0.029| 0.138 (small)      |\n| Extract and Move Method |     < 0.001| 0.213 (small)      |\n| Pull Up Field           |        0.122| 0.258 (small)      |\n| Move Field              |        0.727| 0.030 (negligible) |\n| Overall                 |        0.453| 0.003 (negligible) |."}},{"_id":"5eb23431deb70a6af2247f58","documentRepoId":"5eb233e5deb70a6af2233f58","documentRepoName":"research-bin-ase2018","fkglDelta":1.3666666666666636,"freDelta":-4.4550000000000125,"from":{"commitAuthorEmail":"dipenta@unisannio.it","commitId":"5eb233f4deb70a6af2235fb8","readability":{"daleChallScore":12.801833333333333,"fleschKincaidGradeLevel":14.646666666666672,"fleschReadingEase":16.77000000000001,"papersDomainScore":7.012166666666666},"text":"RQ$_2$: What is the best approach for detecting the sentiment from mined opinions? Our second RQ evaluates the accuracy of pattern-based approach in comparison with six state-of-the-art sentiment analysis tools."},"to":{"commitAuthorEmail":"gabriele.bavota@usi.ch","commitId":"5eb233f5deb70a6af223633c","readability":{"daleChallScore":12.862911111111112,"fleschKincaidGradeLevel":16.013333333333335,"fleschReadingEase":12.314999999999998,"papersDomainScore":8.03818888888889},"text":"RQ$_2$: What is the best approach for detecting the sentiment from mined opinions? Our second RQ evaluates the accuracy of the polarity analyzer component when exploiting (i) a pattern-based approach, or (ii) six state-of-the-art sentiment analysis tools."}},{"_id":"5eb23431deb70a6af2247ff6","documentRepoId":"5eb233e5deb70a6af2233f58","documentRepoName":"research-bin-ase2018","fkglDelta":1.2793721083939147,"freDelta":3.295264375413126,"from":{"commitAuthorEmail":"dipenta@unisannio.it","commitId":"5eb233f4deb70a6af2235fb8","readability":{"daleChallScore":13.352384313725493,"fleschKincaidGradeLevel":19.6264705882353,"fleschReadingEase":-5.277549019607818,"papersDomainScore":8.011649019607844},"text":"RQ$_1$: What is the best approach for identifying opinion aspects in Stack Overflow discussions? This RQ aims at comparing the performance of different possible aspect identification implementations among the pattern-based approach, machine learning approaches and approaches combining patterns and machine learning. In particular, RQ$_1$ assesses how good POME is in (i) discriminating between sentences reporting/not reporting opinions, (ii) classifying opinions according to the quality attribute they refer to."},"to":{"commitAuthorEmail":"gabriele.bavota@usi.ch","commitId":"5eb233f5deb70a6af223633c","readability":{"daleChallScore":12.914258801498127,"fleschKincaidGradeLevel":20.905842696629215,"fleschReadingEase":-1.9822846441946922,"papersDomainScore":8.833697003745318},"text":"RQ$_1$: What is the best approach for identifying opinion aspects in Stack Overflow discussions? This RQ aims at comparing the performance of different implementations of the aspect classifier, and in particular those previously described and exploiting the pattern-based approach, the machine learning approach, or a combination of both (i.e., machine learning exploiting the patterns as predictor variables). RQ$_1$ assesses how good the different variations of the aspect classifier are in (i) discriminating between sentences reporting/not reporting opinions, and (ii) classifying opinions according to the quality attribute they refer to."}},{"_id":"5eb23431deb70a6af2248142","documentRepoId":"5eb233e5deb70a6af2233f58","documentRepoName":"research-bin-ase2018","fkglDelta":-8.4891452991453,"freDelta":27.021923076923088,"from":{"commitAuthorEmail":"dipenta@unisannio.it","commitId":"5eb233eadeb70a6af22346b0","readability":{"daleChallScore":12.710833333333333,"fleschKincaidGradeLevel":25.428888888888892,"fleschReadingEase":-7.099999999999966,"papersDomainScore":8.324722222222222},"text":"The opinion miner is in charge of analyzing the sentences stored by fine-grained liker in the database to identify the ones reporting opinions and classify the quality aspect(s) discussed in them (e.g., performance) and the sentiment of the opinion (i.e.,positive, neutral, or negative). Based on what discussed in Section 2 (i.e., sentiment analysis tools are unsuitable for our purpose), we decided to follow a totally different path for the implementation of the opinion miner (but then also compare it with state-of-the-art sentiment analysis tools, as it will be shown in Section 5)."},"to":{"commitAuthorEmail":"gabriele.bavota@usi.ch","commitId":"5eb233ecdeb70a6af2234a51","readability":{"daleChallScore":10.796741025641026,"fleschKincaidGradeLevel":16.939743589743593,"fleschReadingEase":19.92192307692312,"papersDomainScore":6.140715384615383},"text":"The opinion miner is in charge of analyzing the sentences classified as relevant of the APIs opinion mining (i.e., those assigned to an aspect by the aspect classifier to identify the sentiment of the opinion (i.e.,positive or negative). Based on what discussed in Section 2. Also in this case we investigated two different options for the implementation of the opinion miner, and we evaluate their performance as described in Section 4 to pick the best one for our approach."}},{"_id":"5eb23431deb70a6af224816b","documentRepoId":"5eb233e5deb70a6af2233f58","documentRepoName":"research-bin-ase2018","fkglDelta":-7.150151515151515,"freDelta":21.874772727272727,"from":{"commitAuthorEmail":"dipenta@unisannio.it","commitId":"5eb233efdeb70a6af2235099","readability":{"daleChallScore":11.972087878787878,"fleschKincaidGradeLevel":18.734545454545458,"fleschReadingEase":19.52181818181819,"papersDomainScore":7.187239393939394},"text":"Finally, for RQ$_{3}$ we report and compare the percentage of opinions mined by POME and by Opiner for which the participants agreed/disagreed with the aspects and sentiments automatically assigned by the tools."},"to":{"commitAuthorEmail":"bin.lin@usi.ch","commitId":"5eb233f0deb70a6af22353eb","readability":{"daleChallScore":10.675203030303031,"fleschKincaidGradeLevel":11.584393939393943,"fleschReadingEase":41.39659090909092,"papersDomainScore":5.890354545454546},"text":"Finally, for RQ$_{3}$ we compare the results assigned by POME and Opiner with the ground truth identified by evaluators. We report the percentage of correctly identified aspects and sentiment for both both tools."}},{"_id":"5eb23431deb70a6af2248161","documentRepoId":"5eb233e5deb70a6af2233f58","documentRepoName":"research-bin-ase2018","fkglDelta":2.8483333333333327,"freDelta":-18.640000000000043,"from":{"commitAuthorEmail":"fiorella.zampetti@unisannio.it","commitId":"5eb233fddeb70a6af223837c","readability":{"daleChallScore":18.06516666666667,"fleschKincaidGradeLevel":21.72666666666667,"fleschReadingEase":-33.98999999999995,"papersDomainScore":12.801833333333333},"text":"::: {#tab:datasetRQ3}\n|               |            |            |            |            |            |            |\n|:--------------|-----------:|-----------:|-----------:|-----------:|-----------:|-----------:|\n|               |            |            |            |            |            |            |\n|               |  # pos|  # neg|  # sum|  # pos|  # neg|  # sum|\n| documentation |          13|           3|          16|           9|           4|          13|\n| functional    |         134|          10|         144|          23|          14|          37|\n| performance   |          15|           4|          19|           5|           2|           7|\n| reliability   |           5|          10|          15|           2|          26|          28|\n| usability     |           7|          16|          23|         102|          45|         147|\n| community     |           1|           0|           1|           2|           0|           2|\n| total         |         175|          43|         218|         143|          91|         234|."},"to":{"commitAuthorEmail":"bin.lin@usi.ch","commitId":"5eb233fedeb70a6af22385de","readability":{"daleChallScore":18.24635,"fleschKincaidGradeLevel":24.575000000000003,"fleschReadingEase":-52.629999999999995,"papersDomainScore":13.311975},"text":"::: {#tab:datasetRQ3}\n|               |            |            |            |            |            |            |\n|:--------------|-----------:|-----------:|-----------:|-----------:|-----------:|-----------:|\n|               |            |            |            |            |            |            |\n|               |  # pos|  # neg|  # sum|  # pos|  # neg|  # sum|\n| compatibility |           7|           3|          10|           3|           0|           3|\n| documentation |          13|           3|          16|           9|           4|          13|\n| functional    |         134|          10|         144|          21|          14|          35|\n| performance   |          15|           4|          19|           5|           2|           7|\n| reliability   |           5|          10|          15|           2|          24|          26|\n| usability     |           7|          16|          23|         101|          39|         140|\n| community     |           1|           0|           1|           2|           0|           2|\n| total         |         175|          43|         218|         143|          83|         226|."}},{"_id":"5eb23431deb70a6af2248294","documentRepoId":"5eb233e5deb70a6af2233f58","documentRepoName":"research-bin-ase2018","fkglDelta":4.707104991394152,"freDelta":-16.174012621916262,"from":{"commitAuthorEmail":"dipenta@unisannio.it","commitId":"5eb233f4deb70a6af2235fb8","readability":{"daleChallScore":11.673761904761905,"fleschKincaidGradeLevel":15.255714285714285,"fleschReadingEase":27.245952380952417,"papersDomainScore":7.839047619047619},"text":"Concerning RQ$_{2}$, we compare the accuracy of POME in assessing the sentiment of opinions with that of six state-of-the-art sentiment analysis tools: SentiStrength, NLTK, SentiStrength-SE, Stanford CoreNLP, EmoText, and Senti4SD. Note that we only conduct the comparison on 193 out of 520 sentences containing opinions, from which POME can detect the existence of opinions. The rationale behind this choice is the following. In our manual analysis we discarded sentences not reporting opinions related to API and, as a consequence, we did not label the sentiment of these sentences. However, this does not mean that all discarded sentences are neutral in terms of sentiment. Besides, we only compare the results of 193 sentences which POME can detect the existence of opinions from because our main goal is to guarantee that the sentiment of opinion related sentences extracted by the tool is correctly assigned."},"to":{"commitAuthorEmail":"gabriele.bavota@usi.ch","commitId":"5eb233f5deb70a6af223633c","readability":{"daleChallScore":12.512376626506025,"fleschKincaidGradeLevel":19.962819277108437,"fleschReadingEase":11.071939759036155,"papersDomainScore":8.897798313253013},"text":"Concerning RQ${2}$, we compare the accuracy of POME in assessing the sentiment of opinions with that of six state-of-the-art sentiment analysis tools: SentiStrength, NLTK, SentiStrength-SE, Stanford CoreNLP, EmoText, and Senti4SD. Note that we only conduct the comparison on the subset of 520 sentences containing opinions for which the best configuration of the aspect classifier (output of RQ${1}$) can detect the existence of opinions. The rationale behind this choice is the following. First, in our manual analysis we discarded sentences not reporting opinions related to APIs and, as a consequence, we did not label the sentiment of these sentences (thus leaving us with the 520 sentences labeled with sentiment polarity). Moreover, when envisioning POME as a tool deployed to mine opinions and assign a polarity to them, our priority is to identify the polarity analyzer implementation that is better suited for the sentences identified by the aspect classifier as opinions, since the ones discarded (i.e., do not identified as opinions) will not be shown to the POME user."}},{"_id":"5eb23431deb70a6af2248291","documentRepoId":"5eb233e5deb70a6af2233f58","documentRepoName":"research-bin-ase2018","fkglDelta":-1.88717602996255,"freDelta":5.218284644194739,"from":{"commitAuthorEmail":"gabriele.bavota@usi.ch","commitId":"5eb233f6deb70a6af2236b5f","readability":{"daleChallScore":12.914258801498127,"fleschKincaidGradeLevel":20.905842696629215,"fleschReadingEase":-1.9822846441946922,"papersDomainScore":8.833697003745318},"text":"RQ$_1$: What is the best approach for identifying opinion aspects in Stack Overflow discussions? This RQ aims at comparing the performance of different implementations of the aspect classifier, and in particular those previously described and exploiting the pattern-based approach, the machine learning approach, or a combination of both (i.e., machine learning exploiting the patterns as predictor variables). RQ$_1$ assesses how good the different variations of the aspect classifier are in (i) discriminating between sentences reporting/not reporting opinions, and (ii) classifying opinions according to the quality attribute they refer to."},"to":{"commitAuthorEmail":"dipenta@unisannio.it","commitId":"5eb233f7deb70a6af2236e5f","readability":{"daleChallScore":13.0873,"fleschKincaidGradeLevel":19.018666666666665,"fleschReadingEase":3.236000000000047,"papersDomainScore":8.455566666666666},"text":"RQ$_1$: What is the best approach for identifying opinion aspects in Stack Overflow discussions? This RQ aims at comparing the performance of different implementations of the aspect classifier, i.e., the pattern-based approach or the machine learning approach, including a version employing patterns as features. RQ$_1$ assesses how good the different variations of the aspect classifier are in (i) discriminating between sentences reporting/not reporting opinions, and (ii) classifying opinions according to the quality attribute they refer."}},{"_id":"5eb23431deb70a6af224806d","documentRepoId":"5eb233e5deb70a6af2233f58","documentRepoName":"research-bin-ase2018","fkglDelta":3.4231372549019667,"freDelta":-19.79254901960786,"from":{"commitAuthorEmail":"dipenta@unisannio.it","commitId":"5eb233efdeb70a6af2235099","readability":{"daleChallScore":13.313,"fleschKincaidGradeLevel":16.203333333333333,"fleschReadingEase":14.515000000000043,"papersDomainScore":7.786499999999999},"text":"RQ$_1$: How accurate is POME in mining opinions from Stack Overflow? This RQ evaluates the overall accuracy of POME in performing opinion mining on Stack Overflow. In particular, RQ$_1$ assesses how good POME is in (i) discriminating between sentences reporting/not reporting opinions (ii) classifying opinions according to the quality attribute they refer to, and (iii) assessing the sentiment of the opinion."},"to":{"commitAuthorEmail":"bin.lin@usi.ch","commitId":"5eb233f0deb70a6af22353eb","readability":{"daleChallScore":13.352384313725493,"fleschKincaidGradeLevel":19.6264705882353,"fleschReadingEase":-5.277549019607818,"papersDomainScore":8.011649019607844},"text":"RQ$_1$: What is the best approach for identifying opinion aspects in Stack Overflow discussions? This RQ aims at comparing the performance of different possible aspect identification implementations among the pattern-based approach, machine learning approaches and approaches combining patterns and machine learning. In particular, RQ$_1$ assesses how good POME is in (i) discriminating between sentences reporting/not reporting opinions, (ii) classifying opinions according to the quality attribute they refer to."}},{"_id":"5eb23431deb70a6af2247fa8","documentRepoId":"5eb233e5deb70a6af2233f58","documentRepoName":"research-bin-ase2018","fkglDelta":3.659946605644542,"freDelta":-6.6478375286041285,"from":{"commitAuthorEmail":"dipenta@unisannio.it","commitId":"5eb233eadeb70a6af22346b0","readability":{"daleChallScore":12.78331739130435,"fleschKincaidGradeLevel":24.923913043478265,"fleschReadingEase":-1.6984782608695355,"papersDomainScore":9.007447826086956},"text":"The evaluator also had to assign a negative, neutral, or positive sentiment to the reported opinion and, finally, she had to identify in the selected part of the sentence the lexical tokes (e.g., noun, pronoun, adjective, etc.) referring to: (i) the linked library, and (ii) the quality aspect(s)."},"to":{"commitAuthorEmail":"gabriele.bavota@usi.ch","commitId":"5eb233ecdeb70a6af2234a51","readability":{"daleChallScore":12.83510350877193,"fleschKincaidGradeLevel":28.583859649122807,"fleschReadingEase":-8.346315789473664,"papersDomainScore":8.679840350877193},"text":"The evaluator also had to assign a negative or positive sentiment to the reported opinion (this information will be used in the context of the opinion miner) and, finally, she had to identify in the selected part of the sentence the lexical tokes (e.g., noun, pronoun, adjective, etc.) referring to: (i) the linked API, and (ii) the quality aspect(s)."}},{"_id":"5eb23431deb70a6af22482d2","documentRepoId":"5eb233e5deb70a6af2233f58","documentRepoName":"research-bin-ase2018","fkglDelta":-0.14857142857142414,"freDelta":-9.621428571428595,"from":{"commitAuthorEmail":"dipenta@unisannio.it","commitId":"5eb233efdeb70a6af2235099","readability":{"daleChallScore":13.325004761904763,"fleschKincaidGradeLevel":14.795238095238096,"fleschReadingEase":26.391428571428605,"papersDomainScore":6.933814285714286},"text":"RQ$_2$: How does POME assess the sentiment of sentences as compared to state-of-the-art sentiment analysis tools? Our second RQ aims at comparing the accuracy of POME in identifying the sentiment of the mined opinions with that of six state-of-the-art sentiment analysis tools."},"to":{"commitAuthorEmail":"bin.lin@usi.ch","commitId":"5eb233f0deb70a6af22353eb","readability":{"daleChallScore":12.801833333333333,"fleschKincaidGradeLevel":14.646666666666672,"fleschReadingEase":16.77000000000001,"papersDomainScore":7.012166666666666},"text":"RQ$_2$: What is the best approach for detecting the sentiment from mined opinions? Our second RQ evaluates the accuracy of pattern-based approach in comparison with six state-of-the-art sentiment analysis tools."}},{"_id":"5eb23451deb70a6af224df24","documentRepoId":"5eb233e3deb70a6af2233f53","documentRepoName":"research-fengcai-icpc2020","fkglDelta":5.047996422182473,"freDelta":-16.00574836016696,"from":{"commitAuthorEmail":"csaba.nagy@usi.ch","commitId":"5eb233f9deb70a6af223767f","readability":{"daleChallScore":11.480271794871795,"fleschKincaidGradeLevel":13.181538461538464,"fleschReadingEase":31.430128205128227,"papersDomainScore":7.5327717948717945},"text":"Some subcategories include the simple removal of code that was only temporary implemented in $c_{i}$ (i.e.,Cleaup/Remove Debugging Code) or that become unnecessary after $c_{i}$'s changes (i.e.,Remove Unnecessary Code). Also, in 2 cases developers changed the code implemented in $c_{i}$ to improve its performance. For example, in the $\\mathtt{project}$ project,."},"to":{"commitAuthorEmail":"csaba.nagy@usi.ch","commitId":"5eb233fadeb70a6af223786a","readability":{"daleChallScore":12.218948062015505,"fleschKincaidGradeLevel":18.229534883720937,"fleschReadingEase":15.424379844961265,"papersDomainScore":9.281273643410852},"text":"Some subcategories include the simple removal of code that was only temporary implemented in $c_{i}$ (i.e.,Cleaup/Remove Debugging Code) or that become unnecessary after $c_{i}$'s changes (i.e.,Remove Unnecessary Code). Also, in 2 cases developers changed the code implemented in $c_{i}$ to improve its performance. An examples can be seen in project $\\mathtt{rzwitserloot/lombok}$ where a developer fine tunes a cache clearing mechanism implemented in a previous commit by turning a variable volatile and moving the invocation for the cache clearing after a conditional check."}},{"_id":"5eb23451deb70a6af224e429","documentRepoId":"5eb233e3deb70a6af2233f53","documentRepoName":"research-fengcai-icpc2020","fkglDelta":-4.469201030927838,"freDelta":10.520253436426117,"from":{"commitAuthorEmail":"gabriele.bavota@gmail.com","commitId":"5eb2341bdeb70a6af223d61d","readability":{"daleChallScore":12.728274570446734,"fleschKincaidGradeLevel":20.37670103092784,"fleschReadingEase":6.5609965635738945,"papersDomainScore":9.147037457044673},"text":"However, the main purpose of those code refactoring/clean up tasks is to improve the code comprehensibility without touching any documentation. Variable and method renaming refactoring (i.e., renaming a variable or method to better fit its functionality) is the most common way to make the code easier to understand. Also, variable and method extract refactoring (i.e., replacing literal values or inner method code blocks by introducing new variables or methods) is a standard approach to not only avoid existing or potential redundant code, but also better present and explain the implementation logic of the extracted code snippets."},"to":{"commitAuthorEmail":"gabriele.bavota@gmail.com","commitId":"5eb2341cdeb70a6af223d93b","readability":{"daleChallScore":12.43843086419753,"fleschKincaidGradeLevel":15.907500000000002,"fleschReadingEase":17.08125000000001,"papersDomainScore":9.319418518518518},"text":"However, the main purpose of those code refactoring/clean up tasks is to improve the code understandability. Variable and method renaming refactoring (i.e., renaming a variable or method to better reflect its functionality) is the most common way to make the code easier to comprehend. Also popular are code transformations aimed at replacing literal values with variables or splitting long functions through extract method refactoring. The latter allows not only to foster comprehensibility, but also the reusability of small code snippets."}},{"_id":"5eb23451deb70a6af224d977","documentRepoId":"5eb233e3deb70a6af2233f53","documentRepoName":"research-fengcai-icpc2020","fkglDelta":4.51,"freDelta":-25.210000000000008,"from":{"commitAuthorEmail":"gabriele.bavota@gmail.com","commitId":"5eb2341bdeb70a6af223d61d","readability":{"daleChallScore":18.408266666666666,"fleschKincaidGradeLevel":7.400000000000002,"fleschReadingEase":52.69500000000002,"papersDomainScore":11.8291},"text":"::: {#tab:dataset}\n|                   |             |         |        |           |\n|------------------:|------------:|--------:|-------:|----------:|\n|                   |             |         |        |           |\n|                   |             |     Mean|  Median|  Std. Dev.|\n|     Java files|    1,599,323|    1,068|     360|      2,838|\n|  Effective LOC|  162,243,714|  108,379|  31,392|    305,704|\n|          Stars|    2,895,219|    1,930|     762|      3,455|\n|        Commits|    3,323,198|    2,215|     832|      5,089|."},"to":{"commitAuthorEmail":"gabriele.bavota@gmail.com","commitId":"5eb2341cdeb70a6af223d93b","readability":{"daleChallScore":18.3435,"fleschKincaidGradeLevel":11.910000000000002,"fleschReadingEase":27.485000000000014,"papersDomainScore":10.448500000000001},"text":"::: {#tab:dataset}\n|                   |             |         |        |\n|------------------:|------------:|--------:|-------:|\n|                   |             |         |        |\n|                   |             |     Mean|  Median|\n|     Java files|    1,599,323|    1,068|     360|\n|  Effective LOC|  162,243,714|  108,379|  31,392|\n|          Stars|    2,895,219|    1,930|     762|\n|        Commits|    3,323,198|    2,215|     832|."}},{"_id":"5eb23451deb70a6af224dc9a","documentRepoId":"5eb233e3deb70a6af2233f53","documentRepoName":"research-fengcai-icpc2020","fkglDelta":-3.596544117647058,"freDelta":8.864926470588216,"from":{"commitAuthorEmail":"michele.lanza@usi.ch","commitId":"5eb233f1deb70a6af2235653","readability":{"daleChallScore":11.403064705882354,"fleschKincaidGradeLevel":13.790294117647061,"fleschReadingEase":41.611323529411806,"papersDomainScore":8.306986274509804},"text":"Rodriguez-Perez et al. conducted two case studies to introduce a metric Time To Notify(TNN) which describe how much time it takes for a bug to be notified/reported since the bug was introduced into the source code and examine how this metric is related to the software maintenance and evolution."},"to":{"commitAuthorEmail":"csaba.nagy@usi.ch","commitId":"5eb233f1deb70a6af223587b","readability":{"daleChallScore":11.338225,"fleschKincaidGradeLevel":10.193750000000003,"fleschReadingEase":50.47625000000002,"papersDomainScore":8.377600000000001},"text":"Rodriguez-Perez et al. conducted two case studies and studied the Time To Notify (TNN) metric which describes how much time it takes for a bug to be notified/reported since the bug was introduced into the source code. They examine how this metric is related to software maintenance and evolution. Interestingly, they found relatively high mean values of TTN in the projects: 312 and 431 days."}},{"_id":"5eb23451deb70a6af224e17b","documentRepoId":"5eb233e3deb70a6af2233f53","documentRepoName":"research-fengcai-icpc2020","fkglDelta":-6.585500236518444,"freDelta":30.962135170293237,"from":{"commitAuthorEmail":"lanza@Lightforce2019.mobile.usilu.net","commitId":"5eb2340fdeb70a6af223b5ce","readability":{"daleChallScore":10.94655,"fleschKincaidGradeLevel":17.033571428571427,"fleschReadingEase":22.81142857142862,"papersDomainScore":8.408871428571429},"text":"Given the goal of our work, we considered the author date. After analyzing the distribution of these time intervals (shown in Fig. 1 with \"minutes\" on the x-axis), we considered the first quartile, which is exactly five minutes, as a candidate threshold to identify remedy commits: $c_{i+1}$ commits performed as quick fixes for their predecessor $c_{i}$ commit."},"to":{"commitAuthorEmail":"lanza@Lightforce2019.mobile.usilu.net","commitId":"5eb23410deb70a6af223b873","readability":{"daleChallScore":8.546342384105959,"fleschKincaidGradeLevel":10.448071192052984,"fleschReadingEase":53.77356374172186,"papersDomainScore":6.768660264900663},"text":"Then, given the commit history, our goal was to identify all pairs of subsequent commits $(c_i, c_{i+1})$ in which $c_{i+1}$ has been performed by the developer as a quick remedy fix for $c_i$. In other words, $c_{i+1}$ must (i) have been performed within a relatively short time interval from $c_{i}$; (ii) clearly be a \"compensatory\" fix for $c_i$. To identify the $(c_i, c_{i+1})$ pairs of interest, we adopt the following heuristic-based procedure. First, we compute the time interval between all adjacent (subsequent) commits in each system, by using the author date of each commit. In git it is possible to retrieve the author date (i.e., the date in which the change has been implemented by the author) or the committer date (i.e., the date in which the change has been committed). Given the goal of our work, we considered the author date. We analyzed the distribution of these time intervals (see Fig. 1)."}},{"_id":"5eb23451deb70a6af224d76a","documentRepoId":"5eb233e3deb70a6af2233f53","documentRepoName":"research-fengcai-icpc2020","fkglDelta":6.343622106049288,"freDelta":-14.014414986308196,"from":{"commitAuthorEmail":"csaba.nagy@usi.ch","commitId":"5eb23402deb70a6af22391ac","readability":{"daleChallScore":11.01156925566343,"fleschKincaidGradeLevel":19.22330097087379,"fleschReadingEase":18.392491909385143,"papersDomainScore":8.712054692556634},"text":"While in the cases we analyzed the issue was spotted and fixed quickly by the developer, there might be non-trivial cases in which only a subset of the test suite is executed for regression testing (e.g., due to a limited testing budget) and a non-executed broken test is not identified by the developer. For researchers, this is an opportunity to study test breaking-changes and to develop techniques able to alert the developer when a change she implemented might require a double check of (part of) the test suite. For practitioners, continuous integration practices can help in timely spotting these issues in most of cases."},"to":{"commitAuthorEmail":"gabriele.bavota@gmail.com","commitId":"5eb23403deb70a6af223948a","readability":{"daleChallScore":11.985123076923077,"fleschKincaidGradeLevel":25.56692307692308,"fleschReadingEase":4.3780769230769465,"papersDomainScore":9.555892307692307},"text":"While in the cases we analyzed the issue was spotted and fixed quickly by the developer, there might be non-trivial cases in which only a subset of the test suite is executed for regression testing (e.g., due to a limited testing budget) and a non-executed broken test is not identified by the developer."}},{"_id":"5eb23451deb70a6af224d789","documentRepoId":"5eb233e3deb70a6af2233f53","documentRepoName":"research-fengcai-icpc2020","fkglDelta":-6.607575757575756,"freDelta":24.218636363636392,"from":{"commitAuthorEmail":"csaba.nagy@usi.ch","commitId":"5eb23405deb70a6af22398e1","readability":{"daleChallScore":11.972087878787878,"fleschKincaidGradeLevel":21.237575757575758,"fleschReadingEase":1.5763636363636522,"papersDomainScore":7.6657242424242416},"text":"While the lexical pattern defined to automatically identify remedy commits can return false positives, these have been excluded in our study through manual validation, thus do not influencing our findings in any way."},"to":{"commitAuthorEmail":"csaba.nagy@usi.ch","commitId":"5eb23405deb70a6af2239b92","readability":{"daleChallScore":10.944500000000001,"fleschKincaidGradeLevel":14.630000000000003,"fleschReadingEase":25.795000000000044,"papersDomainScore":7.39175},"text":"In addition to that, we used lexical patterns to identify candidate remedy commits. While these lexical patterns can return false positives, these have been excluded in our study through manual validation, thus do not influencing our findings in any way."}},{"_id":"5eb23451deb70a6af224df16","documentRepoId":"5eb233e3deb70a6af2233f53","documentRepoName":"research-fengcai-icpc2020","fkglDelta":-8.533272727272728,"freDelta":24.84475192604006,"from":{"commitAuthorEmail":"gabriele.bavota@gmail.com","commitId":"5eb2341bdeb70a6af223d61d","readability":{"daleChallScore":14.431627272727273,"fleschKincaidGradeLevel":27.04727272727273,"fleschReadingEase":-20.484090909090895,"papersDomainScore":11.560718181818181},"text":"While these techniques cover most of the inconsistencies fixed in the Code Refactoring/Clean up category (e.g.,Rename Method for Consistency, Fix Improper Exception Name), others are left uncovered (e.g.,Fields Ordering), indicating more potential for additional research in the area of recommending coding convention fixes."},"to":{"commitAuthorEmail":"gabriele.bavota@gmail.com","commitId":"5eb2341cdeb70a6af223d93b","readability":{"daleChallScore":12.434432881355933,"fleschKincaidGradeLevel":18.514000000000003,"fleschReadingEase":4.360661016949166,"papersDomainScore":9.356721016949152},"text":" The inconsistencies fixed with simple refactorings point to the possibility for the software engineering research community to investigate techniques able to learn coding conventions used in a given system and recommend fixes for possible violations. To the best of our knowledge, the only attempt at date has been made by Allamanis et al. with their NATURALIZE tool able to recommend meaningful identifier names and formatting guidelines. Other approaches focus only on rename refactoring suggestions. While these techniques cover most of the inconsistencies fixed in the Code Refactoring/Clean up category (e.g.,Rename Method for Consistency, Fix Improper Exception Name), others are left uncovered (e.g.,Fields Ordering), indicating more potential for additional research in the area of recommending coding convention fixes."}},{"_id":"5eb23451deb70a6af224dcd2","documentRepoId":"5eb233e3deb70a6af2233f53","documentRepoName":"research-fengcai-icpc2020","fkglDelta":-9.872620387742339,"freDelta":25.660425265791133,"from":{"commitAuthorEmail":"csaba.nagy@usi.ch","commitId":"5eb233e8deb70a6af223425c","readability":{"daleChallScore":11.643976923076922,"fleschKincaidGradeLevel":17.16871794871795,"fleschReadingEase":41.434615384615384,"papersDomainScore":8.809874358974358},"text":"Sliwerski et al., studied the day of the week and size of commits for two totally different projects, Eclipse and Mozilla, and found that the commits on Fridays are buggiest and large commits are more likely to contain bugs."},"to":{"commitAuthorEmail":"csaba.nagy@usi.ch","commitId":"5eb233e9deb70a6af22342e0","readability":{"daleChallScore":9.706073983739838,"fleschKincaidGradeLevel":7.296097560975612,"fleschReadingEase":67.09504065040652,"papersDomainScore":7.010220325203253},"text":"Sliwerski et al. studied the day of the week and the size of commits on two completely different projects, Eclipse and Mozilla. They found that the commits on Friday were the buggiest, and large commits were more likely to contain bugs."}},{"_id":"5eb23451deb70a6af224df39","documentRepoId":"5eb233e3deb70a6af2233f53","documentRepoName":"research-fengcai-icpc2020","fkglDelta":5.721414900888583,"freDelta":-19.052714741398944,"from":{"commitAuthorEmail":"csaba.nagy@usi.ch","commitId":"5eb23405deb70a6af22398e1","readability":{"daleChallScore":11.471644588744589,"fleschKincaidGradeLevel":16.48753246753247,"fleschReadingEase":22.570346320346346,"papersDomainScore":7.985540692640692},"text":"Threats to construct validity concern the relation between the theory and the observation, and in this work are mainly due to the manual analysis we performed to identify the reasons behind the quick remedy changes performed by developers. To mitigate subjectivity bias in such a process, every commit was assigned to two authors who manually analyzed it independently. Then, in the case of a disagreement, a third author was assigned to the commit to solve the conflict."},"to":{"commitAuthorEmail":"csaba.nagy@usi.ch","commitId":"5eb23405deb70a6af2239b92","readability":{"daleChallScore":12.585247368421053,"fleschKincaidGradeLevel":22.208947368421054,"fleschReadingEase":3.5176315789474017,"papersDomainScore":8.845510526315788},"text":"Threats to construct validity concern the relation between the theory and the observation, and in this work are mainly due to the manual analysis we performed to identify the reasons behind the quick remedy changes performed by developers."}},{"_id":"5eb23452deb70a6af224fb08","documentRepoId":"5eb233e4deb70a6af2233f54","documentRepoName":"research-msr2019-stackoverflow-reuse","fkglDelta":-1.6661396965866029,"freDelta":1.5259295195954792,"from":{"commitAuthorEmail":"gabriele.bavota@gmail.com","commitId":"5eb233f5deb70a6af223647b","readability":{"daleChallScore":11.81482389380531,"fleschKincaidGradeLevel":17.147853982300887,"fleschReadingEase":22.437356194690267,"papersDomainScore":8.670797345132744},"text":"What are the characteristics of SO posts that have been reused by developers? We focus on three types properties that can be objectively measured in SO answers and, thus, compared in reused and non-reused answers. First, community aspects including, e.g., the reputation of the user who posted the answer, whether the answer has been marked as the \"accepted answer\" by the user who asked the question, etc. Second, the quality of the code snippet included in the answer, assessed using state-of-the-art quality metrics that can be measured on a (possibly incomplete) code snippet (e.g., cyclomatic complexity). Third, the quality of the answer's textual content, mainly assessed through metrics capturing its readability.\n\nWhat is the accuracy of a machine learner-based predictor in identifying posts that are likely to be reused by developers? We use the knowledge acquired as output of RQ$_1$ to devise a machine learning approach using the factors studied in RQ$_1$ as independent variables to predict whether a given SO answer will be reused or not (dependent variable). In the context of RQ$_2$ we also investigate how the performance of the prediction approach are influenced by (i) the choice of the machine learning algorithm, (ii) the balancing of the training set, and (iii) the amount and temporal recency of the posts used to build the training set. Finally, we analyze the importance for the prediction of each independent variable."},"to":{"commitAuthorEmail":"dipenta@unisannio.it","commitId":"5eb233f6deb70a6af2236c1b","readability":{"daleChallScore":12.501557857142858,"fleschKincaidGradeLevel":15.481714285714284,"fleschReadingEase":23.963285714285746,"papersDomainScore":8.836022142857143},"text":"We focus on three types properties that can be objectively measured in SO answers and, thus, compared in reused and non-reused answers. First, community aspects including, the reputation of the user who posted the answer, whether the answer has been marked as the \"accepted answer\" by the user who asked the question, etc. Second, the quality of the code snippet included in the answer, assessed using state-of-the-art quality metrics that can be measured on a (possibly incomplete) code snippet (e.g., cyclomatic complexity). Third, the quality of the answer's textual content, mainly assessed through metrics capturing its readability. The complete list of features is described in detail below and reported in Table [tab:factors]."}},{"_id":"5eb23452deb70a6af224f401","documentRepoId":"5eb233e4deb70a6af2233f54","documentRepoName":"research-msr2019-stackoverflow-reuse","fkglDelta":1.979414032869789,"freDelta":-3.7719472187105225,"from":{"commitAuthorEmail":"rocco.oliveto@unimol.it","commitId":"5eb233f9deb70a6af223739f","readability":{"daleChallScore":12.501557857142858,"fleschKincaidGradeLevel":15.481714285714284,"fleschReadingEase":23.963285714285746,"papersDomainScore":8.836022142857143},"text":"We focus on three types properties that can be objectively measured in SO answers and, thus, compared in reused and non-reused answers. First, community aspects including, the reputation of the user who posted the answer, whether the answer has been marked as the \"accepted answer\" by the user who asked the question, etc. Second, the quality of the code snippet included in the answer, assessed using state-of-the-art quality metrics that can be measured on a (possibly incomplete) code snippet (e.g., cyclomatic complexity). Third, the quality of the answer's textual content, mainly assessed through metrics capturing its readability. The complete list of features is described in detail below and reported in Table [tab:factors]."},"to":{"commitAuthorEmail":"rocco.oliveto@unimol.it","commitId":"5eb233f9deb70a6af2237683","readability":{"daleChallScore":12.723098230088496,"fleschKincaidGradeLevel":17.461128318584073,"fleschReadingEase":20.191338495575224,"papersDomainScore":9.229735398230089},"text":"We focus on three kinds of properties that can be objectively measured in SO answers and, thus, we compared them in reused and non-reused answers: (i) community aspects including, the reputation of the user who posted the answer, whether the answer has been marked as the \"accepted answer\" by the user who asked the question, etc.; (ii) the quality of the code snippet included in the answer, assessed using state-of-the-art quality metrics that can be measured on a (possibly incomplete) code snippet (e.g., cyclomatic complexity); (iii) the quality of the answer's textual content, mainly assessed through metrics capturing its readability. The complete list of features is described in detail below and reported in Table [tab:factors]."}},{"_id":"5eb23452deb70a6af224fc1f","documentRepoId":"5eb233e4deb70a6af2233f54","documentRepoName":"research-msr2019-stackoverflow-reuse","fkglDelta":23.566141668528033,"freDelta":-64.09489069131112,"from":{"commitAuthorEmail":"dipenta@unisannio.it","commitId":"5eb233f3deb70a6af2235c41","readability":{"daleChallScore":11.433476859504133,"fleschKincaidGradeLevel":10.593047520661159,"fleschReadingEase":46.0550258264463,"papersDomainScore":9.215047107438016},"text":"# Words in Answer: number of words in the answer text; # Sentences in Answer: number of sentences in the answer text; # Characters in Answer: number of characters in the answer text; # Syllables in Answer: number of syllables in the answer text; # Complex Words in Answer: the number of words composed of at least 3 syllables; The ARI (Automated Readability Index), SMOG (Simple Measure of Gobbledygook, SMOG Index (easier version of SMOG), Flesch Kincaid, Coleman Liau, and Gunning Fog are different readability metrics to estimate the grade level needed to understand the text. The Flesch Reading Easy (also called Flesch Reading-Ease Score -- FRES) provides an index of simplicity in reading the text. A simpler text will have a higher FRE index and vice versa."},"to":{"commitAuthorEmail":"salgeremia@gmail.com","commitId":"5eb233f3deb70a6af2235de1","readability":{"daleChallScore":14.419512612612612,"fleschKincaidGradeLevel":34.15918918918919,"fleschReadingEase":-18.039864864864825,"papersDomainScore":11.930098198198198},"text":"We analyzed...\nIs Accepted: boolean value, 1 if the answer is accepted, 0 otherwise;\nAnswer Score: answer upvotes minus answer downvotes;\nComment Count: number of the answer comments;\nCreation Date: date when the answer was created;\nUser Reputation: it is a trust measure of the crowd;\nUser Up Votes: number of upvotes received by a user;\nUser Down Votes: number of downvotes received by a user;\nIs Referenced: boolean value, 1 if there is an explicit link to the answer from a GitHub file, 0 otherwise;\n# GitHub Links: number of GitHub links for an answer;\nSnippet LOC: number of snippet lines of code;\nSnippet Complexity: calculates the cyclomatic complexity of the snippet;\nSnippet Readability: @Gabriele;\n# Words: number of words in the answer text;\n# Sentences: number of sentences in the answer text;\n# Characters: number of characters in the answer text;\n# Syllables: number of syllables in the answer text;\n# Complex Words: the number of words composed of at least 3 syllables;\nThe ARI (Automated Readability Index), SMOG (Simple Measure of Gobbledygook, SMOG Index (easier version of SMOG), Flesch Kincaid, Coleman Liau, and Gunning Fog are different readability metrics to estimate the grade level needed to understand the text. The Flesch Reading Easy (also called Flesch Reading-Ease Score -- FRES) provides an index of simplicity in reading the text. A simpler text will have a higher FRE index and vice versa."}},{"_id":"5eb23452deb70a6af224f700","documentRepoId":"5eb233e4deb70a6af2233f54","documentRepoName":"research-msr2019-stackoverflow-reuse","fkglDelta":-5.425797101449277,"freDelta":13.964782608695657,"from":{"commitAuthorEmail":"salgeremia@gmail.com","commitId":"5eb233fbdeb70a6af2237e57","readability":{"daleChallScore":18.455,"fleschKincaidGradeLevel":23.93666666666667,"fleschReadingEase":30.315000000000012,"papersDomainScore":14.770666666666665},"text":"::: {#tab:rq2-gini}\n| Feature                |            MDI|\n|:---------------------------|------------------:|\n| Comment Count              |  0.403 $\\pm$ 0.010|\n| Answer Score               |  0.398 $\\pm$ 0.007|\n| User Reputation            |  0.393 $\\pm$ 0.005|\n| User Up Votes              |  0.380 $\\pm$ 0.000|\n| Is Accepted                |  0.376 $\\pm$ 0.086|\n| Snippet LOC                |  0.350 $\\pm$ 0.007|\n| User Down Votes            |  0.350 $\\pm$ 0.007|\n| # Words in Answer         |  0.310 $\\pm$ 0.007|\n| Snippet Readability        |  0.302 $\\pm$ 0.007|\n| # Sentences in Answer     |  0.286 $\\pm$ 0.010|\n| # Complex Words in Answer |  0.281 $\\pm$ 0.003|\n| Flesch Kincaid             |  0.277 $\\pm$ 0.007|\n| Snippet Complexity         |  0.277 $\\pm$ 0.022|\n| Flesch Reading Easy        |  0.269 $\\pm$ 0.006|\n| Coleman Liau               |  0.257 $\\pm$ 0.007|\n| Creation Date              |  0.239 $\\pm$ 0.006|."},"to":{"commitAuthorEmail":"salgeremia@gmail.com","commitId":"5eb233fcdeb70a6af22380bf","readability":{"daleChallScore":18.962013043478258,"fleschKincaidGradeLevel":18.510869565217394,"fleschReadingEase":44.27978260869567,"papersDomainScore":15.186143478260869},"text":"::: {#tab:rq2-gini}\n| Feature         |            MDI|\n|:--------------------|------------------:|\n| Is Accepted         |  0.502 $\\pm$ 0.020|\n| Comment Count       |  0.416 $\\pm$ 0.006|\n| Answer Score        |  0.396 $\\pm$ 0.003|\n| User Reputation     |  0.372 $\\pm$ 0.004|\n| LOC                 |  0.356 $\\pm$ 0.003|\n| User Down Votes     |  0.351 $\\pm$ 0.002|\n| Snippet Complexity  |  0.323 $\\pm$ 0.009|\n| Snippet Readability |  0.322 $\\pm$ 0.005|\n| # Words            |  0.304 $\\pm$ 0.006|\n| # Sentences        |  0.296 $\\pm$ 0.005|\n| Flesch Kincaid      |  0.284 $\\pm$ 0.005|\n| Flesch Reading Easy |  0.268 $\\pm$ 0.003|\n| Coleman Liau        |  0.260 $\\pm$ 0.007|\n| Creation Date       |  0.243 $\\pm$ 0.006|."}},{"_id":"5eb23452deb70a6af224f4d2","documentRepoId":"5eb233e4deb70a6af2233f54","documentRepoName":"research-msr2019-stackoverflow-reuse","fkglDelta":-4.466816468420173,"freDelta":4.863001968503966,"from":{"commitAuthorEmail":"rocco.oliveto@unimol.it","commitId":"5eb233f9deb70a6af2237683","readability":{"daleChallScore":11.119047517730497,"fleschKincaidGradeLevel":22.071914893617024,"fleschReadingEase":20.53,"papersDomainScore":8.655359574468086},"text":"Given the well-known reuse of SO posts in open source projects, we start from the assumption that posts useful in the past for somebody are likely to be useful in future, and we empirically investigate what the characteristics of SO posts that have been previously \"reused\" by developers are, and compare them with that of \"non-reused\" posts. Note that in this paper we adopt a loose definition of reuse of a post: We assume a post to have been reused if it has been mentioned (i.e., linked) at least once in the source code of an open source project hosted on GitHub. Such a link might indicate the willingness of a developer to (i) indicate the reuse of the post's code snippets, (ii) document the rationale of an implementation choice, or (iii) to simply refer the post as an interesting source of information."},"to":{"commitAuthorEmail":"rocco.oliveto@unimol.it","commitId":"5eb233fadeb70a6af22377fd","readability":{"daleChallScore":10.681851181102363,"fleschKincaidGradeLevel":17.60509842519685,"fleschReadingEase":25.393001968503967,"papersDomainScore":7.449252755905511},"text":"Given that many SO answers have inspired solutions in open source projects, we conjecture that answers useful in the past for somebody are likely to be useful in future. Thus, we empirically investigate which are the characteristics of SO answers that have been previously \"leveraged\" by developers, and compare them with that of \"non-leveraged\" answers. In this paper we assume an answer to have been leveraged if it has been mentioned (i.e., linked) at least once in the source code of an open source project hosted on GitHub. Such a link might indicate the willingness of a developer to (i) indicate the reuse of the answer's code snippets, (ii) document the rationale of an implementation choice, or (iii) to simply refer the answer as an interesting source of information."}},{"_id":"5eb23452deb70a6af224f45e","documentRepoId":"5eb233e4deb70a6af2233f54","documentRepoName":"research-msr2019-stackoverflow-reuse","fkglDelta":-20.747631578947367,"freDelta":54.35157894736844,"from":{"commitAuthorEmail":"rocco.oliveto@unimol.it","commitId":"5eb233f9deb70a6af223739f","readability":{"daleChallScore":13.786866666666667,"fleschKincaidGradeLevel":34.615,"fleschReadingEase":-24.870000000000005,"papersDomainScore":12.471033333333335},"text":"To keep into account the strong unbalancing of our dataset (i.e., we have many more not-reused than reused answers), we experimented each model when (i) not balancing the training sets, (ii) balancing the training sets by under-sampling the majority class by means of the Weka implementations of the SpreadSubSample filter, and (iii) balancing the training sets by generating artificial instances of the minority class by means of the Weka implementation of the SMOTE filter."},"to":{"commitAuthorEmail":"rocco.oliveto@unimol.it","commitId":"5eb233f9deb70a6af2237683","readability":{"daleChallScore":11.019557894736844,"fleschKincaidGradeLevel":13.867368421052635,"fleschReadingEase":29.481578947368433,"papersDomainScore":9.565215789473683},"text":"In our dataset we have many more not-reused than reused answers. In order to keep into account such a strong unbalancing, we experimented each machine learning technique when (i) not balancing the training sets; (ii) balancing the training sets by under-sampling the majority class by means of the Weka implementations of the SpreadSubSample filter; and (iii) balancing the training sets by generating artificial instances of the minority class by means of the Weka implementation of the SMOTE filter."}},{"_id":"5eb23452deb70a6af224face","documentRepoId":"5eb233e4deb70a6af2233f54","documentRepoName":"research-msr2019-stackoverflow-reuse","fkglDelta":4.4126336898395735,"freDelta":-17.53595142602495,"from":{"commitAuthorEmail":"gabriele.bavota@gmail.com","commitId":"5eb233e9deb70a6af2234300","readability":{"daleChallScore":12.093633333333333,"fleschKincaidGradeLevel":8.959411764705884,"fleschReadingEase":51.01401960784315,"papersDomainScore":10.700398039215687},"text":"Sojer and Henkel focused on the legal and economic risks of code reuse from the Internet. They surveyed . They found that \"as is\" or ad-hoc reuse is a common practice in commercial software development."},"to":{"commitAuthorEmail":"salgeremia@gmail.com","commitId":"5eb233e9deb70a6af22343ac","readability":{"daleChallScore":12.793897402597402,"fleschKincaidGradeLevel":13.372045454545457,"fleschReadingEase":33.4780681818182,"papersDomainScore":10.128053246753247},"text":"Sojer and Henkel focused on the legal and economic risks of code reuse from the Internet. They surveyed 869 professional software developers to investigate if the reuse of code snippets from internet is a common practice in commercial software development. They found that the 88% developers reuse internet code and the 19% of them consider reuse as a very important activity for their work. Furthermore, the analysis shows a growth in the importance of internet code reuse in recent years."}},{"_id":"5eb23452deb70a6af224f3df","documentRepoId":"5eb233e4deb70a6af2233f54","documentRepoName":"research-msr2019-stackoverflow-reuse","fkglDelta":-9.48304347826087,"freDelta":27.023260869565206,"from":{"commitAuthorEmail":"gabriele.bavota@gmail.com","commitId":"5eb23415deb70a6af223c538","readability":{"daleChallScore":12.440056521739129,"fleschKincaidGradeLevel":23.897826086956524,"fleschReadingEase":5.6580434782609075,"papersDomainScore":10.037230434782611},"text":"Figures 2 and 3 report the MCC and the Precision$_l$, respectively, obtained by the Random Forest (i) on the five different datasets, containing SO answers characterized by different recency (see the five lines having different colors), and (ii) when using different buckets for training (i.e., oldest 10%, 20%, etc., see $x$-axis)."},"to":{"commitAuthorEmail":"dipenta@unisannio.it","commitId":"5eb23416deb70a6af223c768","readability":{"daleChallScore":10.955995652173913,"fleschKincaidGradeLevel":14.414782608695655,"fleschReadingEase":32.681304347826114,"papersDomainScore":8.553169565217392},"text":"Fig. 2 and 3 report the MCC and the Precision$_l$, respectively, obtained by the Random Forest (i) on the five different datasets, containing SO answers characterized by different recency (see the five lines having different colors), and (ii) when using different buckets for training (i.e., oldest 10%, 20%, etc., see $x$-axis)."}},{"_id":"5eb23452deb70a6af224fba6","documentRepoId":"5eb233e4deb70a6af2233f54","documentRepoName":"research-msr2019-stackoverflow-reuse","fkglDelta":-8.239825218476902,"freDelta":31.765131086142304,"from":{"commitAuthorEmail":"dipenta@unisannio.it","commitId":"5eb23413deb70a6af223bf56","readability":{"daleChallScore":14.289833333333332,"fleschKincaidGradeLevel":25.035555555555558,"fleschReadingEase":-4.279999999999944,"papersDomainScore":13.588055555555556},"text":"Since the analysis involves multiple comparisons, we adjust $p$-values using the Benjamini-Hochberg procedure , which ranks $p$-values, keeping the largest $p$-value unaltered, multiplying the second largest by the number of $p$-values divided by the rank (i.e., two), and treating the remaining ones similarly to the second."},"to":{"commitAuthorEmail":"dipenta@unisannio.it","commitId":"5eb23414deb70a6af223c20b","readability":{"daleChallScore":12.559427340823971,"fleschKincaidGradeLevel":16.795730337078655,"fleschReadingEase":27.48513108614236,"papersDomainScore":10.962685767790262},"text":"As detailed later, these datasets (i.e., first 10%, first 20%, etc.) are also the training sets used in RQ$_2$ where, obviously, we test the machine learning models on unseen data. Therefore, when performing statistics to address RQ$_1$, we do not consider the last bucket (most recent 10%). Since the analysis involves multiple comparisons, we adjust $p$-values using the Benjamini-Hochberg procedure , which ranks $p$-values, keeping the largest $p$-value unaltered, multiplying the second largest by the number of $p$-values divided by the rank (i.e., two), and treating the remaining ones similarly to the second."}},{"_id":"5eb23452deb70a6af224fd92","documentRepoId":"5eb233e4deb70a6af2233f54","documentRepoName":"research-msr2019-stackoverflow-reuse","fkglDelta":4.871818181818181,"freDelta":-14.148939393939372,"from":{"commitAuthorEmail":"salgeremia@gmail.com","commitId":"5eb23429deb70a6af2245048","readability":{"daleChallScore":10.000560606060606,"fleschKincaidGradeLevel":13.65818181818182,"fleschReadingEase":29.79393939393941,"papersDomainScore":5.981287878787879},"text":"Table 1 shows the number of identified clones. We found that, out of the 500 snippets considered as non-leveraged, only 30 (4%) have at least one detected clone in the considered GitHub files. Thus, while we acknowledge a certain level of noise in our analysis (i.e., misclassification of leveraged snippets as non-leveraged), such a noise should be quite limited."},"to":{"commitAuthorEmail":"gabriele.bavota@gmail.com","commitId":"5eb23429deb70a6af2245255","readability":{"daleChallScore":10.387833333333335,"fleschKincaidGradeLevel":18.53,"fleschReadingEase":15.645000000000039,"papersDomainScore":6.7035},"text":"We found that, out of the 500 snippets considered as non-leveraged, only 30 (4%) have at least one detected clone in the considered GitHub files. Thus, while we acknowledge a certain level of noise in our analysis (i.e., misclassification of leveraged snippets as non-leveraged), we believe that the findings reported in the following are unlikely to be substantially influenced by such a noise."}},{"_id":"5eb23455deb70a6af225135a","documentRepoId":"5eb233e4deb70a6af2233f55","documentRepoName":"research-fengcai-icpc2019","fkglDelta":3.2079999999999984,"freDelta":-19.081305084745765,"from":{"commitAuthorEmail":"fengcai.wen@gmail.com","commitId":"5eb233f3deb70a6af2235d74","readability":{"daleChallScore":10.362868333333335,"fleschKincaidGradeLevel":8.804000000000002,"fleschReadingEase":49.041000000000025,"papersDomainScore":6.08641},"text":"The remainder of the paper is structured as follows. We review related work in Section 2. In Section 3 we describe our study design to investigate the research questions. Then our results are present in Section 4. We declare the threats to validity in Section 5 and conclude our findings in Section 6."},"to":{"commitAuthorEmail":"gabriele.bavota@gmail.com","commitId":"5eb233f4deb70a6af2235eca","readability":{"daleChallScore":10.912457966101694,"fleschKincaidGradeLevel":12.012,"fleschReadingEase":29.95969491525426,"papersDomainScore":7.96855966101695},"text":"The remainder of the paper is structured as follows. We review related literature in Section 2. In Section 3 we describe the study design we adopted to answer our research question. The achieved results are presented in Section 4. Section 5 discuss the threats that could affect the validity of our study, while Section 6 summarizes our observations and outlines directions for future work."}},{"_id":"5eb23455deb70a6af22509a3","documentRepoId":"5eb233e4deb70a6af2233f55","documentRepoName":"research-fengcai-icpc2019","fkglDelta":4.323392349444303,"freDelta":-27.13747113810632,"from":{"commitAuthorEmail":"csaba.nagy@usi.ch","commitId":"5eb233ffdeb70a6af2238a69","readability":{"daleChallScore":11.981378538812786,"fleschKincaidGradeLevel":15.802739726027399,"fleschReadingEase":25.10515981735162,"papersDomainScore":7.9798031963470315},"text":"More interesting for the aim of our study are the cases in which the distributions of $MCC$ and $CCC$ are quite low, indicating possible code-comment inconsistencies introduced during software evolution. The first two change categories that leap to the eye from this perspective are Literal and Name, both with a median $MCC$ and $CCC$ lower than 10%. The literal category groups changes related to \"values\" in source code (e.g., boolean values, String values, etc.) while the name category represents changes to identifiers or to the names of object types. In these categories, developers rarely update comments as consequence of code changes. While updating comments when changing literal values and identifiers might not always be needed (e.g., the comment does not document the changed literal value or a renamed identifier), we found several cases of code-comment inconsistencies introduced in these situations. Concerning the Literal category, one example is from the."},"to":{"commitAuthorEmail":"gabriele.bavota@gmail.com","commitId":"5eb23400deb70a6af2238d60","readability":{"daleChallScore":13.143824528301886,"fleschKincaidGradeLevel":20.126132075471702,"fleschReadingEase":-2.032311320754701,"papersDomainScore":8.07910754716981},"text":"While the importance of code comments is undisputed, developers do not always have the chance to carefully commenting new code and/or to update comments as consequence of code changes. This latter scenario might result in the introduction of code-comment inconsistencies, manifesting when the source code does not co-evolve with the related comments. For example, if a method comment is not updated after major changes to the method's application logic, the comment might provide misleading information to developers comprehending the method, hindering program comprehension rather than fostering it. Given the potential harmfulness of code-comment inconsistencies, several researchers studied the co-evolution of code and comments, while others proposed techniques and tools able to detect code-comment inconsistencies automatically. These techniques are able to identify specific types of code-comment inconsistencies. For example, @TCOMMENT detects inconsistencies between Javadoc comments related to null values and exceptions with the behavior implemented in the related method's body, while Fraco focuses on inconsistencies introduced as result of rename refactoring operations. Still, more research is needed in this area to increase the types of code-comment inconsistencies that can be automatically identified. Also, the empirical evidence provided by studies that pioneered the investigation of code-comment evolution is limited to the analysis of the change history of a few software systems (less than 10)."}},{"_id":"5eb23455deb70a6af2250ab9","documentRepoId":"5eb233e4deb70a6af2233f55","documentRepoName":"research-fengcai-icpc2019","fkglDelta":0.5647696749932862,"freDelta":-6.275488517324732,"from":{"commitAuthorEmail":"gabriele.bavota@gmail.com","commitId":"5eb233fedeb70a6af223852b","readability":{"daleChallScore":12.653001369863016,"fleschKincaidGradeLevel":14.885034246575344,"fleschReadingEase":20.849606164383573,"papersDomainScore":7.786220547945206},"text":"We present the results in the form of a hierarchical taxonomy that can be seen in Figure [fig:taxonomy]. The different types of comment changes are represented either as grouping nodes or leaves in the taxonomy, and changes related to code-comment inconsistencies are marked with . The 59 different types are grouped into six main categories: (i) Comment changes related to the application logic are grouped in a separate category; (ii) code design/quality groups together changes related to source code quality or to the structure/design of the code (e.g., refactoring related to class hierarchy); (iii) process category contains changes to comments related to development/maintenance processes; (iv) formatting/wording are fixes of the style or phrasing of comments; (v) copyright/license comments are also separated into another category; (vi) finally others group together cases originating from deletion of outdated comments or addition of missing comments in order to document new code."},"to":{"commitAuthorEmail":"csaba.nagy@usi.ch","commitId":"5eb233ffdeb70a6af22387f4","readability":{"daleChallScore":13.458327450980391,"fleschKincaidGradeLevel":15.44980392156863,"fleschReadingEase":14.574117647058841,"papersDomainScore":8.04019019607843},"text":"The different change types are grouped into six main categories: (i) Comment changes related to the Application Logic are grouped in a separate category; (ii) Code Design/Quality groups together changes related to source code quality or to the structure/design of the code (e.g., refactoring related to class hierarchy); (iii) Maintenance category contains changes to comments related to development/maintenance processes; (iv) Formatting/Readability are fixes of the style or phrasing of comments; (v) Copyright/License comments are also separated into another category; (vi) finally Others group together cases originating from deletion of outdated comments or addition of missing comments in order to document new code."}},{"_id":"5eb23455deb70a6af2250d84","documentRepoId":"5eb233e4deb70a6af2233f55","documentRepoName":"research-fengcai-icpc2019","fkglDelta":-6.779461241191182,"freDelta":21.888764491929976,"from":{"commitAuthorEmail":"gabriele.bavota@gmail.com","commitId":"5eb23400deb70a6af2238d60","readability":{"daleChallScore":11.021646987951808,"fleschKincaidGradeLevel":20.78295180722892,"fleschReadingEase":19.975150602409656,"papersDomainScore":8.358273493975904},"text":"In most cases, a change occurred in a comment update (113), while in a few cases (12) a new comment was added. For updates, which were in most cases closely related to an inconsistency, we observed three main reasons why developers updated comments: (i) the comment was wrong before (35) (i.e., it was already wrong when it was first added, or it became outdated after a change), (ii) they updated the comment together/following a new implementation (25), (iii) they wanted to explain the actual implementation (53) in more detail."},"to":{"commitAuthorEmail":"gabriele.bavota@gmail.com","commitId":"5eb23401deb70a6af2238fcd","readability":{"daleChallScore":10.61146603773585,"fleschKincaidGradeLevel":14.003490566037737,"fleschReadingEase":41.86391509433963,"papersDomainScore":7.632220754716981},"text":"In most cases, the change occurred in the form of a comment update (113), while in a few cases (12) a new comment was added. We observed three main reasons why developers update comments: (i) the comment wrongly describes the application logic (35), due to an error done when the comment was written in the first place or to an inconsistency introduced during the code evolution (in these cases we were not able to trace back to the specific cause of the problem); (ii) the comment needs to be updated as a consequence of a new implementation logic (25); (iii) the comment is improved to explain the actual implementation in more details (53)."}},{"_id":"5eb23455deb70a6af2250f94","documentRepoId":"5eb233e4deb70a6af2233f55","documentRepoName":"research-fengcai-icpc2019","fkglDelta":-4.458969871510856,"freDelta":20.39138568896766,"from":{"commitAuthorEmail":"gabriele.bavota@gmail.com","commitId":"5eb23405deb70a6af2239a13","readability":{"daleChallScore":14.433591891891892,"fleschKincaidGradeLevel":23.39675675675676,"fleschReadingEase":-6.779459459459446,"papersDomainScore":11.446294594594596},"text":"Categories exhibiting low values of both $MCC$ and $CCC$ and showing statistically significant lower chance to trigger comment updates when compared to most of the other categories are Array, Lambda Expression, Iteration, Literal, Method Invocation, and Name."},"to":{"commitAuthorEmail":"gabriele.bavota@gmail.com","commitId":"5eb23406deb70a6af2239c61","readability":{"daleChallScore":12.914873770491804,"fleschKincaidGradeLevel":18.937786885245902,"fleschReadingEase":13.611926229508214,"papersDomainScore":9.549791803278689},"text":"Categories exhibiting low values of both $MCC$ and $CCC$ and showing statistically significant lower chance to trigger comment updates when compared to most of the other categories are Array, Lambda Expression, Iteration, Literal, Method Invocation, and Name. Due to the lack of space, we only discuss two exemplar cases from these categories, while more qualitative analysis will be reported in RQ$_2$."}},{"_id":"5eb23455deb70a6af22507c3","documentRepoId":"5eb233e4deb70a6af2233f55","documentRepoName":"research-fengcai-icpc2019","fkglDelta":3.691388542963887,"freDelta":-13.70081672893312,"from":{"commitAuthorEmail":"gabriele.bavota@gmail.com","commitId":"5eb23400deb70a6af2238d60","readability":{"daleChallScore":11.909842424242424,"fleschKincaidGradeLevel":15.159090909090912,"fleschReadingEase":38.62530303030303,"papersDomainScore":8.680069696969698},"text":"For instance, in a commit of QR Code generator a comment describing how an array element of the QR code is calculated was fixed (following a copy-paste mistake). In WordPress for Android, the previously misleading comment of the \"getPath()\" method was replaced from \"descendants must implement this to send their specific request to the stats api\" to \"descendants must implement this to return their specific path to the stats rest api\". We also observed interesting cases when the fix was in an example code inside the comment (see)."},"to":{"commitAuthorEmail":"gabriele.bavota@gmail.com","commitId":"5eb23401deb70a6af2238fcd","readability":{"daleChallScore":12.584845205479454,"fleschKincaidGradeLevel":18.8504794520548,"fleschReadingEase":24.92448630136991,"papersDomainScore":8.25881780821918},"text":"In WordPress for Android, the previously misleading comment of the \"getPath()\" method was replaced from \"descendants must implement this to send their specific request to the stats api\" to \"descendants must implement this to return their specific path to the stats rest api\". We also observed interesting cases in which the comment was fixed to update a code usage example reported in the comment and not aligned with the actual code implementation (see)."}},{"_id":"5eb23455deb70a6af2251726","documentRepoId":"5eb233e4deb70a6af2233f55","documentRepoName":"research-fengcai-icpc2019","fkglDelta":3.934103160989949,"freDelta":-29.689770685289517,"from":{"commitAuthorEmail":"gabriele.bavota@gmail.com","commitId":"5eb233fedeb70a6af223852b","readability":{"daleChallScore":11.505239622641511,"fleschKincaidGradeLevel":15.00537735849057,"fleschReadingEase":34.680896226415086,"papersDomainScore":7.9301452830188675},"text":"Although these types of changes are typically not due to code-comment inconsistencies, we found cases where the comment contained references to other source code elements, or links to, for instance, bug reports. These cases can be considered dangerous from the inconsistency point of view, hence, we marked these as well in the taxonomy."},"to":{"commitAuthorEmail":"csaba.nagy@usi.ch","commitId":"5eb233ffdeb70a6af22387f4","readability":{"daleChallScore":12.496969264069266,"fleschKincaidGradeLevel":18.93948051948052,"fleschReadingEase":4.9911255411255695,"papersDomainScore":9.010865367965367},"text":"Although these types of changes are usually not performed because of code-comment inconsistencies, we found cases where the comment contained references, for example, to other source code elements or bug reports. These cases can be considered dangerous from an inconsistency point of view, as invalid/outdated references can be disturbing in the code. For example in Google Guava a commit says: \"Updated a comment in ListenerCallQueue to point at SequentialExecutor instead of the deprecated SerializingExecutor wrapper interface\"."}},{"_id":"5eb23455deb70a6af2250a67","documentRepoId":"5eb233e4deb70a6af2233f55","documentRepoName":"research-fengcai-icpc2019","fkglDelta":-2.9956686802730594,"freDelta":10.332042428316186,"from":{"commitAuthorEmail":"fengcai.wen@gmail.com","commitId":"5eb233f1deb70a6af22355d6","readability":{"daleChallScore":12.187652755905512,"fleschKincaidGradeLevel":13.94216535433071,"fleschReadingEase":32.804376640419974,"papersDomainScore":8.789280052493439},"text":"Other authors focused on the evolution of code comments. Jiang and Hassan conducted a study on the evolution of comments in PostgreSQL. They investigated the trend of the percentage of commented functions in PostgreSQL over time. They divided comments into header comments and non-header comments according to the relative location of a comment with its associated function. By investigating how many header comments and non-header comments were added and deleted during the evolutionary history of PostgreSQL, their result reveals the proportion of commented functions remains constant over time. Fluri et al. conducted an empirical research on three open source systems (ArgoUML, Azureus, and JDT Core) to study how comments and source code co-evolved over time. They observed that 97% of comment changes triggered by source code changes were done in the same revision as the associated source code change, but newly added code barely got commented. In this study, an algorithm called ChangeDistiller was proposed to track fine-grained code changes down to the statement level as well as the comment changes. In Fluri's other paper, an similar approach was proposed to investigate the co-evolution between code and comment with experiments on multiple revisions of eight different software systems. They found that the ratio between the growth of code and comments is constant, however, newly added code still barely trigger the addition of comments in half of the investigated systems. The type of code entity highly influences whether the entity is commented or not. For example, if-statements are commented more often than simple statements. They also found that over 50% of the comment changes are related to source code changes and 90% of these comment changes co-evolve with the code changes simultaneously on the observed systems. Arafat et al. looked at the density of comments, which is defined as the number of comment lines divided by the number of lines of code of the same code body, in 5,229 open source projects in different programming languages. Their research indicated that successful open source projects follow a consistent practice of documenting their source code and it has led to an average comment density of about 19%. Indeed, the average comment density is dependent with programming language (the highest mean density is 25% on Java projects) but remains constant on two other dimensions such as projects size and team size."},"to":{"commitAuthorEmail":"gabriele.bavota@gmail.com","commitId":"5eb233f1deb70a6af2235826","readability":{"daleChallScore":12.367271396895788,"fleschKincaidGradeLevel":10.94649667405765,"fleschReadingEase":43.13641906873616,"papersDomainScore":8.323490909090909},"text":"Fluri et al. conducted an empirical research on three open source systems (ArgoUML, Azureus, and JDT Core) to study how comments and source code co-evolved over time. They observed that 97% of code changes triggered comment changes within the same revision. However, newly added code barely got commented. Fluri et al. used ChangeDistiller to track (i) fine-grained code changes down to the statement level and (ii) changes implemented in code comments. In a follow-up paper, Fluri et al. investigated the co-evolution between code and comment in eight software systems. They found that the ratio between the growth of code and comments is constant bug confirmed the previous observation about the frequent lack of comment updates for newly added code. They also found that the type of code entity impacts its likelihood of being commented (e.g.,if statements are commented more often than other types of statements). They also found that 90% of comment changes represent a simultaneous co-evolution with code changes (i.e., they change in the same revision)."}},{"_id":"5eb23455deb70a6af225180e","documentRepoId":"5eb233e4deb70a6af2233f55","documentRepoName":"research-fengcai-icpc2019","fkglDelta":4.729697933227349,"freDelta":-28.566224165341822,"from":{"commitAuthorEmail":"gabriele.bavota@gmail.com","commitId":"5eb23404deb70a6af22397c3","readability":{"daleChallScore":13.2179,"fleschKincaidGradeLevel":18.66705882352941,"fleschReadingEase":21.786764705882376,"papersDomainScore":10.431429411764706},"text":"Categories exhibiting low values of both $MCC$ and $CCC$ and showing statistically significant lower chance to trigger comment updates when compared to most of the other categories are Array, Lambda Expression, Name, and Type. Since changes to the Name and Type categories are much more frequent in our dataset as compared to Array and Lambda Expression (hundreds of thousands vs hundreds), we focus our qualitative discussion on them."},"to":{"commitAuthorEmail":"gabriele.bavota@gmail.com","commitId":"5eb23405deb70a6af2239a13","readability":{"daleChallScore":14.433591891891892,"fleschKincaidGradeLevel":23.39675675675676,"fleschReadingEase":-6.779459459459446,"papersDomainScore":11.446294594594596},"text":"Categories exhibiting low values of both $MCC$ and $CCC$ and showing statistically significant lower chance to trigger comment updates when compared to most of the other categories are Array, Lambda Expression, Iteration, Literal, Method Invocation, and Name."}},{"_id":"5eb23455deb70a6af2251617","documentRepoId":"5eb233e4deb70a6af2233f55","documentRepoName":"research-fengcai-icpc2019","fkglDelta":4.43552543405422,"freDelta":-15.770546756015847,"from":{"commitAuthorEmail":"gabriele.bavota@gmail.com","commitId":"5eb23405deb70a6af2239a13","readability":{"daleChallScore":11.618842857142859,"fleschKincaidGradeLevel":15.758877551020408,"fleschReadingEase":25.71647959183676,"papersDomainScore":8.23527142857143},"text":"Code changes to the Literal and Name categories are the ones less frequently triggering comment updates. This is also confirmed by the statistical analysis (Fig. [fig:rq1-component-stats]), in which these two categories exhibit, as compared to other categories, statistically significant lower values of $MCC$ and $CCC$ accompanied by at least a \"small\" and in most cases by a \"large\" effect size^3. However, as we also observed through manual inspection, these type of changes can be responsible for the introduction of code-comment inconsistencies. The Constructor also exhibits extremely low values but, as said, only for the $MCC$ metric."},"to":{"commitAuthorEmail":"gabriele.bavota@gmail.com","commitId":"5eb23406deb70a6af2239c61","readability":{"daleChallScore":13.075264179104478,"fleschKincaidGradeLevel":20.19440298507463,"fleschReadingEase":9.945932835820912,"papersDomainScore":9.77586119402985},"text":"Code changes to the Array, Lambda Expression, Iteration, Literal, Method Invocation, and Name categories are the ones less frequently triggering comment updates. This is also confirmed by the statistical analysis (Fig. [fig:rq1-component-stats]), in which these categories exhibit, as compared to other categories, statistically significant lower values of $MCC$ and $CCC$ accompanied by at least a \"small\" and in most cases by a \"large\" effect size."}},{"_id":"5eb23476deb70a6af225c6c9","documentRepoId":"5eb233e5deb70a6af2233f57","documentRepoName":"research-emadpres-adana-tse","fkglDelta":-2.214758125472411,"freDelta":11.425935374149645,"from":{"commitAuthorEmail":"michele.lanza@usi.ch","commitId":"5eb2340edeb70a6af223b1a0","readability":{"daleChallScore":10.823848148148148,"fleschKincaidGradeLevel":15.043703703703706,"fleschReadingEase":35.29666666666668,"papersDomainScore":8.484588888888888},"text":"Then, in all sentences the description standardizer (iii) converts each infinitive verb not following a modal verb in third person, to give the developer the feeling that the description is referring to \"the code\" she selects in the IDE (see e.g., the first description in Table 1); and (iv) converts each gerund verb following a conjunction in third person (2nd description in Table 1). Once the descriptions are standardized, they are stored together with the related code in the ADANA knowledge base (see Figure [fig:architecture])."},"to":{"commitAuthorEmail":"m.linaresv@uniandes.edu.co","commitId":"5eb2340fdeb70a6af223b545","readability":{"daleChallScore":10.54469319727891,"fleschKincaidGradeLevel":12.828945578231295,"fleschReadingEase":46.72260204081633,"papersDomainScore":8.39639387755102},"text":"The description standardizer starts by splitting the description into sentences. Then, it converts all the instances of how-to and howto (if any) to how to. For all sentences starting with how (e.g.,how to implement [...], how do you manage [...], etc.), it: (i) removes the first two words (e.g.,how to, how do, etc.) and (ii) removes the 3rd word if it is a personal pronoun (I, you, he, etc.). Then, in all sentences the description standardizer (iii) converts each infinitive verb not following a modal verb in third person, to give the developer the feeling that the description is referring to \"the code\" she selects in the IDE (see e.g., the first description in Table 1); and (iv) converts each gerund verb following a conjunction in third person (2nd description in Table 1). Once the descriptions are standardized, they are stored together with the related code in the ADANA knowledge base (see Figure [fig:architecture])."}},{"_id":"5eb23476deb70a6af225b916","documentRepoId":"5eb233e5deb70a6af2233f57","documentRepoName":"research-emadpres-adana-tse","fkglDelta":7.909230769230771,"freDelta":-22.8642307692308,"from":{"commitAuthorEmail":"gabriele.bavota@usi.ch","commitId":"5eb23404deb70a6af223977e","readability":{"daleChallScore":11.33925,"fleschKincaidGradeLevel":11.68,"fleschReadingEase":46.94500000000005,"papersDomainScore":6.997},"text":"We answer RQ$_{2}$ by reporting the percentage of true and false positives classified by the participants^3 as well as by discussing example cases of true and false positives, to highlight strengths and weaknesses of the ASIA clone detector. See Section 3.2."},"to":{"commitAuthorEmail":"gabriele.bavota@usi.ch","commitId":"5eb23405deb70a6af2239b0f","readability":{"daleChallScore":12.453720512820512,"fleschKincaidGradeLevel":19.58923076923077,"fleschReadingEase":24.08076923076925,"papersDomainScore":8.000130769230768},"text":"We answer RQ$_{2}$ by reporting the percentage of true and false positives classified by the participants^1 as well as by discussing example cases of true and false positives, to highlight strengths and weaknesses of the ASIA clone detector (Section 3.2)."}},{"_id":"5eb23476deb70a6af225bc94","documentRepoId":"5eb233e5deb70a6af2233f57","documentRepoName":"research-emadpres-adana-tse","fkglDelta":22.374472222222217,"freDelta":-56.39725,"from":{"commitAuthorEmail":"emad.aghajani@usi.ch","commitId":"5eb233f9deb70a6af223755b","readability":{"daleChallScore":10.263600740740742,"fleschKincaidGradeLevel":10.86177777777778,"fleschReadingEase":55.66100000000003,"papersDomainScore":8.216748888888889},"text":"The description standardizer then converts the descriptions in a suitable \"code comment format\". For all sentences starting with \"how\" (e.g.,how to implement [...], how do you manage [...], etc.): (i) we remove the first two words (e.g.,how to, how do, etc.); (ii) if the 3rd word is a personal pronoun (I, you, he, etc.) we remove it; (iii) we convert each infinitive verb not following a modal verb in third person, to give the developer the feeling that the description is referring to \"the code\" she selects in the IDE (see e.g., the first description in Table 1); and (iv) we convert each gerund verb following a conjunction in third person (2nd description in Table 1)."},"to":{"commitAuthorEmail":"emad.aghajani@usi.ch","commitId":"5eb233fbdeb70a6af2237dea","readability":{"daleChallScore":13.0323125,"fleschKincaidGradeLevel":33.23625,"fleschReadingEase":-0.7362499999999699,"papersDomainScore":11.0585625},"text":"replacing all how-to and howto with how to (if the description has it);\n\nSplitting the description into sentences (See Table  [tab:standardizer]);\n\nFor all sentences starting with how (e.g.,how to implement [...], how do you manage [...], etc.):\n\nwe remove the first two words ( e.g.,how to, how do, etc.);\n\nif the 3rd word is a personal pronoun (I, you, he, etc.) we remove it;\n\nwe convert each infinitive verb not following a modal verb in third person, to give the developer the feeling that the description is referring to \"the code\" she selects in the IDE (see e.g., the first description in Table 1); and\n\nwe convert each gerund verb following a conjunction in third person (2nd description in Table  1)\n\nFor other types of sentences ( e.g.,Utils for Android views, Theme and Style customization, etc.):\n\nWe find first word which is either a verb or noun or determiner and discard words before it.\n\nWe do the same we do in steps \"c\" and \"d\" for \"how [...]\" sentences.\n:::."}},{"_id":"5eb23476deb70a6af225bded","documentRepoId":"5eb233e5deb70a6af2233f57","documentRepoName":"research-emadpres-adana-tse","fkglDelta":-3.3531514084506995,"freDelta":8.010475352112664,"from":{"commitAuthorEmail":"emad.aghajani@usi.ch","commitId":"5eb23400deb70a6af2238b94","readability":{"daleChallScore":13.0323125,"fleschKincaidGradeLevel":33.23625,"fleschReadingEase":-0.7362499999999699,"papersDomainScore":11.0585625},"text":"replacing all how-to and howto with how to (if the description has it);\n\nSplitting the description into sentences (See Table  [tab:standardizer]);\n\nFor all sentences starting with how (e.g.,how to implement [...], how do you manage [...], etc.):\n\nwe remove the first two words ( e.g.,how to, how do, etc.);\n\nif the 3rd word is a personal pronoun (I, you, he, etc.) we remove it;\n\nwe convert each infinitive verb not following a modal verb in third person, to give the developer the feeling that the description is referring to \"the code\" she selects in the IDE (see e.g., the first description in Table 1); and\n\nwe convert each gerund verb following a conjunction in third person (2nd description in Table  1)\n\nFor other types of sentences ( e.g.,Utils for Android views, Theme and Style customization, etc.):\n\nWe find first word which is either a verb or noun or determiner and discard words before it.\n\nWe do the same we do in steps \"c\" and \"d\" for \"how [...]\" sentences.\n:::."},"to":{"commitAuthorEmail":"emad.aghajani@usi.ch","commitId":"5eb23401deb70a6af2239049","readability":{"daleChallScore":12.606761971830986,"fleschKincaidGradeLevel":29.8830985915493,"fleschReadingEase":7.274225352112694,"papersDomainScore":10.716409859154929},"text":"replacing all how-to and howto with how to (if any);\n\nSplitting the description into sentences ^2;\n\nFor all sentences starting with how (e.g.,how to implement [...], how do you manage [...], etc.):\n\nwe remove the first two words ( e.g.,how to, how do, etc.);\n\nif the 3rd word is a personal pronoun (I, you, he, etc.) we remove it;\n\nFor other types of sentences ( e.g.,Utils for Android views, Theme and Style customization, etc.):\n\nWe find the first word which is either a verb, noun, or determiner and remove all words before it.\n\nwe convert each infinitive verb not following a modal verb in third person, to give the developer the feeling that the description is referring to \"the code\" she selects in the IDE (see e.g., the first description in Table 1); and\n\nwe convert each gerund verb following a conjunction in third person (2nd description in Table  1)\n:::."}},{"_id":"5eb23476deb70a6af225b830","documentRepoId":"5eb233e5deb70a6af2233f57","documentRepoName":"research-emadpres-adana-tse","fkglDelta":5.779835302542068,"freDelta":-10.566050841389142,"from":{"commitAuthorEmail":"gabriele.bavota@usi.ch","commitId":"5eb23404deb70a6af223977e","readability":{"daleChallScore":11.800184210526314,"fleschKincaidGradeLevel":18.28982456140351,"fleschReadingEase":20.33543859649123,"papersDomainScore":8.586780701754385},"text":"The participants to the study have been identified using convenience sampling among personal contacts of the authors. We invited developers and CS students/professors to take part in our study by using a Web application we developed to perform the following steps. First, we collected demographic data about participants (years of experience in programming, in Java, and in Android, their current position, etc.). Each participant was then required to assess the correctness of all clones identified by ASIA for eight snippets randomly selected from the 40 object of this study. The Web application was designed to automatically balance the number of evaluations for each of the 40 snippets (i.e., the number of participants assessing the correctness of each identified clone was roughly the same). In total, we collected 501 evaluations across the 182 clones of the 39 snippets (2.78(??) evaluations per clone on average). The eight snippets were presented individually (i.e., each snippet in a different page) to participants, and each clone identified by ASIA for it was shown below the snippet with two radio buttons allowing the participant to express her assessment as: it is a clone or it is not a clone. We instructed participants to consider a clone as a true positive not only if it represented an exact copy of the related snippet (type-1 clone), but also if it differed for variable renaming (type-2), for the addition/deletion of few lines of code do not changing the main feature implemented in the snippet (type-3), or even if it represented a totally different implementation of the same functionality (type-4). Indeed, given the main goal of ADANA(i.e., documenting a piece of code to explain what it implements), any type of code clone represents a valuable source of information."},"to":{"commitAuthorEmail":"gabriele.bavota@usi.ch","commitId":"5eb23405deb70a6af2239b0f","readability":{"daleChallScore":12.18955306122449,"fleschKincaidGradeLevel":24.069659863945578,"fleschReadingEase":9.769387755102088,"papersDomainScore":9.074519047619047},"text":"The eight snippets were presented individually (i.e., each snippet in a different page) to participants, and each clone identified by ASIA for it was shown below the snippet with two radio buttons allowing the participant to express her assessment as: it is a clone or it is not a clone. We instructed participants to consider a clone as a true positive not only if it represented an exact copy of the related snippet (type-1 clone), but also if it differed for variable renaming (type-2), for the addition/deletion of few lines of code do not changing the main feature implemented in the snippet (type-3), or even if it represented a totally different implementation of the same functionality (type-4). Indeed, given the main goal of ADANA(i.e., documenting a piece of code to explain what it implements), any type of code clone represents a valuable source of information."}},{"_id":"5eb23476deb70a6af225ccc7","documentRepoId":"5eb233e5deb70a6af2233f57","documentRepoName":"research-emadpres-adana-tse","fkglDelta":-7.113157894736844,"freDelta":18.93789473684214,"from":{"commitAuthorEmail":"emad.aghajani@usi.ch","commitId":"5eb233f1deb70a6af22357b1","readability":{"daleChallScore":12.169721052631578,"fleschKincaidGradeLevel":18.793157894736844,"fleschReadingEase":28.00710526315791,"papersDomainScore":8.014457894736843},"text":"We answer RQ$_{2}$ by reporting the percentage of true and false positives classified by the participants^1 as well as by discussing example cases of true and false positives, to highlight strengths and weaknesses of the ASIA clone detector."},"to":{"commitAuthorEmail":"emad.aghajani@usi.ch","commitId":"5eb233f3deb70a6af2235b96","readability":{"daleChallScore":11.33925,"fleschKincaidGradeLevel":11.68,"fleschReadingEase":46.94500000000005,"papersDomainScore":6.997},"text":"We answer RQ$_{2}$ by reporting the percentage of true and false positives classified by the participants^1 as well as by discussing example cases of true and false positives, to highlight strengths and weaknesses of the ASIA clone detector. See Section 3.2."}},{"_id":"5eb23476deb70a6af225bc6a","documentRepoId":"5eb233e5deb70a6af2233f57","documentRepoName":"research-emadpres-adana-tse","fkglDelta":5.181326530612246,"freDelta":-22.008112244897944,"from":{"commitAuthorEmail":"gabriele.bavota@usi.ch","commitId":"5eb23418deb70a6af223cb69","readability":{"daleChallScore":9.363128571428572,"fleschKincaidGradeLevel":12.748673469387757,"fleschReadingEase":47.298112244897965,"papersDomainScore":6.7851693877551025},"text":"This clearly represents a case of \"false positive\" comment. We did not observe any strong impact of this comment on the participants performance, likely due to the fact that it was compensated by other injected useful comments and by the still useful context hint (i.e., parsing a web page)."},"to":{"commitAuthorEmail":"emad.aghajani@usi.ch","commitId":"5eb23419deb70a6af223cf64","readability":{"daleChallScore":11.613224242424241,"fleschKincaidGradeLevel":17.930000000000003,"fleschReadingEase":25.29000000000002,"papersDomainScore":8.861936363636364},"text":"This clearly represents a case of \"false positive\" comment. We did not observe any strong impact of this comment on the participants performance, likely due to the fact that it was compensated by other injected useful comments and by the still useful context hint (i.e., parsing a web page). In addition the results show that ADANA group participants for this code snippet performed overall better (*i.e.,*17% increase in average understandability and 112 seconds on average faster in terms of speed). We also observed another similar case (see code snippet #16 in replication package) where the injected comment ( \"// Runs YouTube Video.\") provided only the context (i.e., showing a resource loaded from a URL in a WebView) correctly, but helped participants to perform better by increasing the correctness measure 28% and reducing the spent time by half."}},{"_id":"5eb23476deb70a6af225c32f","documentRepoId":"5eb233e5deb70a6af2233f57","documentRepoName":"research-emadpres-adana-tse","fkglDelta":-17.220698591549297,"freDelta":41.53297464788733,"from":{"commitAuthorEmail":"gabriele.bavota@usi.ch","commitId":"5eb23404deb70a6af223977e","readability":{"daleChallScore":12.606761971830986,"fleschKincaidGradeLevel":29.8830985915493,"fleschReadingEase":7.274225352112694,"papersDomainScore":10.716409859154929},"text":"replacing all how-to and howto with how to (if any);\n\nSplitting the description into sentences ^2;\n\nFor all sentences starting with how (e.g.,how to implement [...], how do you manage [...], etc.):\n\nwe remove the first two words ( e.g.,how to, how do, etc.);\n\nif the 3rd word is a personal pronoun (I, you, he, etc.) we remove it;\n\nFor other types of sentences ( e.g.,Utils for Android views, Theme and Style customization, etc.):\n\nWe find the first word which is either a verb, noun, or determiner and remove all words before it.\n\nwe convert each infinitive verb not following a modal verb in third person, to give the developer the feeling that the description is referring to \"the code\" she selects in the IDE (see e.g., the first description in Table 1); and\n\nwe convert each gerund verb following a conjunction in third person (2nd description in Table  1)\n:::."},"to":{"commitAuthorEmail":"gabriele.bavota@usi.ch","commitId":"5eb23405deb70a6af2239b0f","readability":{"daleChallScore":10.5609,"fleschKincaidGradeLevel":12.662400000000002,"fleschReadingEase":48.80720000000002,"papersDomainScore":8.6661},"text":"The description standardizer starts by splitting the description into sentences. Then, it converts all the instances of how-to and howto (if any) to how to. For all sentences starting with how (e.g.,how to implement [...], how do you manage [...], etc.), it: (i) removes the first two words (e.g.,how to, how do, etc.) and (ii) removes the 3rd word if it is a personal pronoun (I, you, he, etc.). Then, in all sentences the description standardizer (iii) converts each infinitive verb not following a modal verb in third person, to give the developer the feeling that the description is referring to \"the code\" she selects in the IDE (see e.g., the first description in Table 1); and (iv) converts each gerund verb following a conjunction in third person (2nd description in Table 1)."}},{"_id":"5eb23476deb70a6af225bf9c","documentRepoId":"5eb233e5deb70a6af2233f57","documentRepoName":"research-emadpres-adana-tse","fkglDelta":-11.315560975609756,"freDelta":34.46195411326991,"from":{"commitAuthorEmail":"michele.lanza@usi.ch","commitId":"5eb2341cdeb70a6af223d955","readability":{"daleChallScore":13.521205084745764,"fleschKincaidGradeLevel":28.520000000000003,"fleschReadingEase":-4.326271186440636,"papersDomainScore":10.71112033898305},"text":"We also found a case which both adana and uncommented group performed equally (see code snippet #8 in replication package), although the injected comment (\"// Reads Distinct Contacts with Contact Number and Names\") describe the snippet correctly. Although we did not find any clear evidence to explain the case, we believe the complexity of code snippet (two while-structure and three if-statements and one switch-case statement) is a potential factor that persuaded participants to review the code snippet manually, skipping the code comment, which is reasonable reason considering the fact that the average spent time on this code snippet for both groups was virtually equal ($\\sim$200 seconds) and relatively higher in comparison to other similar LOC code snippets in the study."},"to":{"commitAuthorEmail":"gabriele.bavota@usi.ch","commitId":"5eb2341ddeb70a6af223dd12","readability":{"daleChallScore":11.425331219512195,"fleschKincaidGradeLevel":17.204439024390247,"fleschReadingEase":30.135682926829276,"papersDomainScore":9.114599512195122},"text":"This clearly represents a case of \"false positive\" comment. We did not observe any strong impact of this comment on the participants performance, likely due to the fact that it was compensated by the still useful context hint (i.e., parsing a web page). A case in which the participants performed equally both with and without the comments injected by ADANA is represented by code snippet #8 (see replication package). This case is interesting since, despite the fact that the injected comment (\"//Reads Distinct Contacts with Contact Number and Names\") correctly describes the snippet, it did not benefit the correctness achieved by participants nor the time they spent comprehending the code. Our conjecture is that the complexity of the code snippet, including two while loops, three if statements, and one switch-case statement, probably pushed the developers to carefully inspect the whole code in both scenarios, thus reaching a similar comprehension level in roughly the same amount of time ($\\sim$200 seconds) when working with the two treatments."}},{"_id":"5eb23476deb70a6af225bfbd","documentRepoId":"5eb233e5deb70a6af2233f57","documentRepoName":"research-emadpres-adana-tse","fkglDelta":9.457730916695713,"freDelta":-28.029183803880585,"from":{"commitAuthorEmail":"michele.lanza@usi.ch","commitId":"5eb23409deb70a6af223a5cd","readability":{"daleChallScore":12.309203752759382,"fleschKincaidGradeLevel":15.089900662251658,"fleschReadingEase":31.700104856512183,"papersDomainScore":8.440130905077265},"text":"SO documentation was a straightforward resource from where to mine code snippets and their description since it included pages related to a given topic (e.g.,device display metrics) showing snippets (and related descriptions) aimed at dealing with common tasks related to the topic (e.g., programmatically capturing the size of the device display). The code miner scraped all Android-related topics that were already grouped together in the SO documentation. Each topic contained one or more examples (i.e., pairs of $\\langle code, description\\rangle$), showing how to deal with tasks related to the topic (e.g., the \"Intent\" topic, contained 19 pairs). Some preprocessing was needed to identify in each example the related code and description. As for the code, we identify it as the text delimited by the $\\mathtt{}$ HTML tags. These tags are used in SO to format the code elements in the questions/answers and, in this case, in the examples reported in the SO documentation."},"to":{"commitAuthorEmail":"michele.lanza@usi.ch","commitId":"5eb2340adeb70a6af223a8e8","readability":{"daleChallScore":14.136815789473685,"fleschKincaidGradeLevel":24.54763157894737,"fleschReadingEase":3.6709210526315985,"papersDomainScore":10.812605263157895},"text":"SO documentation is a straightforward resource from where to mine code snippets and their description since it includes pages related to a given topic (e.g.,device display metrics) showing snippets (and related descriptions) aimed at dealing with common tasks related to the topic (e.g., programmatically capturing the size of the device display).\nThe code miner scrapes all Android-related topics that were already grouped together in the SO documentation. Each topic contains one or more examples (i.e., pairs of $\\langle code, description\\rangle$), showing how to deal with tasks related to the topic (e.g., the \"Intent\" topic, contained 19 pairs)."}},{"_id":"5eb234b5deb70a6af225d63e","documentRepoId":"5eb233e3deb70a6af2233f52","documentRepoName":"research-emadpres-icse2020","fkglDelta":-0.97359903381642,"freDelta":7.870760869565203,"from":{"commitAuthorEmail":"gabriele.bavota@gmail.com","commitId":"5eb2341fdeb70a6af223e5f1","readability":{"daleChallScore":12.472055555555556,"fleschKincaidGradeLevel":23.340555555555554,"fleschReadingEase":-32.20249999999996,"papersDomainScore":10.015833333333333},"text":"To overcome this deadlock, recent research initiatives have advocated for the development of automated context-aware recommender systems that automatically generate high-quality documentation, contextual to any given task at hand; and exemplified by a first wave of automated approaches for the generation and recommendation of documentation (e.g.,)."},"to":{"commitAuthorEmail":"michele.lanza@usi.ch","commitId":"5eb23420deb70a6af223e908","readability":{"daleChallScore":11.985778260869566,"fleschKincaidGradeLevel":22.366956521739134,"fleschReadingEase":-24.331739130434755,"papersDomainScore":9.582952173913045},"text":"To overcome this deadlock, recent research initiatives have advocated for the development of automated context-aware recommender systems that automatically generate high-quality documentation, contextual to any given task at hand. This has led to a first wave of automated approaches for the generation and recommendation of documentation (e.g.,)."}},{"_id":"5eb234b5deb70a6af225f65a","documentRepoId":"5eb233e3deb70a6af2233f52","documentRepoName":"research-emadpres-icse2020","fkglDelta":-9.191946817082997,"freDelta":31.348211925866195,"from":{"commitAuthorEmail":"lmorenoc@colostate.edu","commitId":"5eb233fcdeb70a6af2238100","readability":{"daleChallScore":15.07554705882353,"fleschKincaidGradeLevel":26.12882352941177,"fleschReadingEase":-31.71029411764701,"papersDomainScore":10.663635294117647},"text":"(Empirical) Studies. A variety of empirical studies have targeted software documentation artifacts aiming at (i) investigating its importance and impact in software life cycle, (ii) describing developers issues and concerns when dealing with software documentation, (iii) investigating the quality attributes required in documentation artifacts, (iv) providing guidelines and recommendations for constructing it, and (v) proposing frameworks and tools for assessing developers' concern in this context (such as cost, benefit and quality attributes)."},"to":{"commitAuthorEmail":"lmorenoc@colostate.edu","commitId":"5eb233fddeb70a6af22383bd","readability":{"daleChallScore":12.796413424657535,"fleschKincaidGradeLevel":16.936876712328772,"fleschReadingEase":-0.36208219178081436,"papersDomainScore":8.686687397260274},"text":"The empirical studies in the literature can be classified based on their main goal into five broad categories: Studies (i) investigating the importance and impact of documentation in the software life cycle; (ii) describing developers issues and concerns when dealing with software documentation; (iii) investigating the quality attributes required in documentation artifacts; (iv) providing guidelines and recommendations on how to write and maintain documentation; and (v) proposing frameworks and tools for assessing developers' concerns in this context."}},{"_id":"5eb234b5deb70a6af225d7d1","documentRepoId":"5eb233e3deb70a6af2233f52","documentRepoName":"research-emadpres-icse2020","fkglDelta":7.001353276353278,"freDelta":-27.932371794871813,"from":{"commitAuthorEmail":"emadpres@gmail.com","commitId":"5eb233efdeb70a6af22351b6","readability":{"daleChallScore":13.078322222222225,"fleschKincaidGradeLevel":15.460185185185185,"fleschReadingEase":8.265833333333376,"papersDomainScore":7.814988888888889},"text":"Previous studies have investigated software documentation from different aspects, mainly focusing on tools & approaches and (empirical) studies. In the following, we summarize the closest ones to ours."},"to":{"commitAuthorEmail":"gabriele.bavota@gmail.com","commitId":"5eb233f0deb70a6af2235486","readability":{"daleChallScore":13.732061538461538,"fleschKincaidGradeLevel":22.461538461538463,"fleschReadingEase":-19.666538461538437,"papersDomainScore":8.266292307692307},"text":"Previous studies have investigated software documentation from different aspects, mainly focusing on tools & approaches for manual and automated documentation, and (empirical) studies aimed at investigation different aspects such as documentation issues, developer concerns, among other. In the following, we summarize the closest ones to our with special emphasis on the empirical studies."}},{"_id":"5eb234b5deb70a6af225dbd8","documentRepoId":"5eb233e3deb70a6af2233f52","documentRepoName":"research-emadpres-icse2020","fkglDelta":-8.868333333333332,"freDelta":20.835000000000008,"from":{"commitAuthorEmail":"csaba.nagy@usi.ch","commitId":"5eb2342adeb70a6af224544c","readability":{"daleChallScore":11.609591666666667,"fleschKincaidGradeLevel":26.484166666666667,"fleschReadingEase":-9.322499999999991,"papersDomainScore":7.662091666666666},"text":"Moreover, since our goal is to further research in the context of documentation recommender systems, the second contribution of this paper is a study with practitioners to understand what types of documentation they perceive as useful when confronted with specific software engineering tasks, to answer our second RQ:."},"to":{"commitAuthorEmail":"lmorenoc@colostate.edu","commitId":"5eb2342bdeb70a6af2245662","readability":{"daleChallScore":11.406066666666666,"fleschKincaidGradeLevel":17.615833333333335,"fleschReadingEase":11.512500000000017,"papersDomainScore":7.458566666666666},"text":"Moreover, since our goal is to further research in the context of documentation recommender systems, the second contribution of this paper is an insight into the types of documentation that practitioners perceive as useful when confronted with specific software engineering tasks. Therefore, we formulate our second RQ as:."}},{"_id":"5eb234b5deb70a6af225edbf","documentRepoId":"5eb233e3deb70a6af2233f52","documentRepoName":"research-emadpres-icse2020","fkglDelta":-0.952924710424714,"freDelta":6.2382850707851105,"from":{"commitAuthorEmail":"gabriele.bavota@gmail.com","commitId":"5eb23404deb70a6af2239559","readability":{"daleChallScore":15.216001190476192,"fleschKincaidGradeLevel":25.625357142857148,"fleschReadingEase":-22.16369047619048,"papersDomainScore":9.71769761904762},"text":"The two principal lines of research in the software documentation field are devoted to (i) the development of tools & approaches to automatically generate or recommend pieces of documentation, and (ii) (empirical) studies aimed at investigating different aspects such as documentation issues and developer concerns, among others. Concerning the automated approaches, representative examples are (i) software summarization techniques providing abstractive and extractive summaries of software artifacts, such as bug reports, classes and methods, unit tests, commit messages, release notes, user reviews, code snippets, and user stories; (ii) recommender systems supporting developers in finding APIs and code usage examples, code fragments implementing specific features or, more in general, useful crowdsourced knowledge for a given implementation task."},"to":{"commitAuthorEmail":"lmorenoc@colostate.edu","commitId":"5eb23404deb70a6af2239808","readability":{"daleChallScore":15.073727027027028,"fleschKincaidGradeLevel":24.672432432432434,"fleschReadingEase":-15.925405405405371,"papersDomainScore":9.099132432432432},"text":"Concerning the development of automated approaches, representative examples are the software summarization techniques that provide abstractive and/or extractive summaries of software artifacts such as bug reports, classes and methods, unit tests, code changes, user reviews, code snippets, and user stories. Equally important are the recommendation systems that support developers in finding APIs and code usage examples, code fragments implementing specific features or, more in general, useful crowdsourced knowledge for a given implementation task."}},{"_id":"5eb234b5deb70a6af225d2ab","documentRepoId":"5eb233e3deb70a6af2233f52","documentRepoName":"research-emadpres-icse2020","fkglDelta":10.616666666666667,"freDelta":-74.33500000000001,"from":{"commitAuthorEmail":"michele.lanza@usi.ch","commitId":"5eb23437deb70a6af224af7e","readability":{"daleChallScore":17.012500000000003,"fleschKincaidGradeLevel":15.433333333333337,"fleschReadingEase":11.130000000000024,"papersDomainScore":14.907166666666669},"text":"::: {#tab:participantExprience}\n|                  Role| <3 years | 3-5 years | 5-10 years | >10 years |         |\n|-------------------------:|:-------------:|:-------------:|:--------------:|:--------------:|--------:|\n|             Developer|       12      |       8       |       10       |       25       |       55|\n|             Architect|       1       |       1       |        2       |       22       |       26|\n|        Technical Lead|       0       |       0       |        6       |       13       |       19|\n|  Tester/Test Engineer|       1       |       0       |        7       |        3       |       11|\n|                Others|       4       |       2       |        4       |       25       |       35|\n|                          |       18      |       11      |       29       |       88       |  146|."},"to":{"commitAuthorEmail":"michele.lanza@usi.ch","commitId":"5eb23437deb70a6af224b059","readability":{"daleChallScore":15.285725,"fleschKincaidGradeLevel":26.050000000000004,"fleschReadingEase":-63.204999999999984,"papersDomainScore":13.311975},"text":"::: {#tab:participantRolePopulation}\n| Role                              |  Population|  <3y|  3-5y|  5-10y|  >10y|\n|:--------------------------------------|---------------:|---------:|---------:|----------:|----------:|\n| Developer                         |              55|        12|         8|         10|         25|\n| Architect/Technical Engineer      |              26|         1|         1|          2|         22|\n| Technical Lead                    |              19|         0|         0|          6|         13|\n| Test Analyst/Tester/Test Engineer |              11|         1|         0|          7|          3|\n| Others                            |              35|         4|         2|          4|         25|\n|                                       |         146|        18|        11|         29|         88|."}},{"_id":"5eb234b5deb70a6af225f79b","documentRepoId":"5eb233e3deb70a6af2233f52","documentRepoName":"research-emadpres-icse2020","fkglDelta":-2.363693762391339,"freDelta":14.571680138274644,"from":{"commitAuthorEmail":"emadpres@gmail.com","commitId":"5eb23449deb70a6af224c8d5","readability":{"daleChallScore":12.618405220883535,"fleschKincaidGradeLevel":22.212048192771086,"fleschReadingEase":-14.909317269076297,"papersDomainScore":8.433104016064258},"text":"In this work, we conducted two large-scale surveys with a diversified population of 146 professional software practitioners with the goal of identifying (i) documentation issues relevant to practitioners, together with the solutions that they apply when these issues arise; and (ii) documentation types useful in the context of specific software engineering tasks. For both surveys, we manually inspected the responses and qualitatively discussed our findings with the goal of highlighting lessons learned, recommendations for researchers, and confirmation/refutation of previous findings reported in the literature."},"to":{"commitAuthorEmail":"gabriele.bavota@gmail.com","commitId":"5eb2344adeb70a6af224c9c2","readability":{"daleChallScore":12.437886497890295,"fleschKincaidGradeLevel":19.848354430379747,"fleschReadingEase":-0.33763713080165303,"papersDomainScore":8.240544725738395},"text":"Moreover, since our goal is to further research in the context of documentation recommender systems, the second contribution of this paper is an insight into the types of documentation that practitioners perceive as useful when confronted with specific software engineering tasks. Therefore, we formulate our second RQ as:\nRQ$_2$: What types of documentation are perceived as useful by practitioners in the context of specific software engineering tasks?\nTo answer these two research questions, we performed two surveys with 146 professional software practitioners. In the first survey, we focused on the documentation issues that practitioners perceive as more severe, together with the solutions that they apply when these issues arise. In the second survey, we studied the types of documentation that practitioners consider important given specific tasks. Most participants (125) are from a multinational corporation active in automation technology, others (21) have been recruited in specialized online forums. The result is a diversified population of practitioners acting in various roles (e.g., developers, testers)."}},{"_id":"5eb234b5deb70a6af225f6fd","documentRepoId":"5eb233e3deb70a6af2233f52","documentRepoName":"research-emadpres-icse2020","fkglDelta":-8.442521994134895,"freDelta":18.969550342130987,"from":{"commitAuthorEmail":"emadpres@gmail.com","commitId":"5eb233efdeb70a6af22351b6","readability":{"daleChallScore":15.149354545454544,"fleschKincaidGradeLevel":23.560909090909092,"fleschReadingEase":4.5113636363636545,"papersDomainScore":10.84299090909091},"text":"Software summarization techniques and tools with the goal of providing abstractive and extractive summaries has been studied for a diverse set of software artifacts, such as bug reports, classes and methods, unit tests, commit messages, release notes, user reviews, code examples and user stories."},"to":{"commitAuthorEmail":"gabriele.bavota@gmail.com","commitId":"5eb233f0deb70a6af2235486","readability":{"daleChallScore":13.82995376344086,"fleschKincaidGradeLevel":15.118387096774198,"fleschReadingEase":23.48091397849464,"papersDomainScore":10.009792473118281},"text":"Tools & Approaches. A plethora of works have been focused on supporting the automated generation and retrieval. For example, software summarization techniques and tools with the goal of providing abstractive and extractive summaries has been porposed for a diverse set of software artifacts, such as bug reports, classes and methods, unit tests, commit messages, release notes, user reviews, code snippets, and user stories."}},{"_id":"5eb234b5deb70a6af225f837","documentRepoId":"5eb233e3deb70a6af2233f52","documentRepoName":"research-emadpres-icse2020","fkglDelta":0.7485628481107902,"freDelta":-4.357524035325412,"from":{"commitAuthorEmail":"gabriele.bavota@gmail.com","commitId":"5eb23404deb70a6af2239559","readability":{"daleChallScore":12.796413424657535,"fleschKincaidGradeLevel":16.936876712328772,"fleschReadingEase":-0.36208219178081436,"papersDomainScore":8.686687397260274},"text":"The empirical studies in the literature can be classified based on their main goal into five broad categories: Studies (i) investigating the importance and impact of documentation in the software life cycle; (ii) describing developers issues and concerns when dealing with software documentation; (iii) investigating the quality attributes required in documentation artifacts; (iv) providing guidelines and recommendations on how to write and maintain documentation; and (v) proposing frameworks and tools for assessing developers' concerns in this context."},"to":{"commitAuthorEmail":"lmorenoc@colostate.edu","commitId":"5eb23404deb70a6af2239808","readability":{"daleChallScore":13.758656776556778,"fleschKincaidGradeLevel":17.685439560439562,"fleschReadingEase":-4.719606227106226,"papersDomainScore":8.55316227106227},"text":"Closer to our work is the empirical research on software documentation aspects, particularly the studies that directly interview or survey software practitioners. These empirical studies can be broadly classified into five categories: (i) studies investigating the importance and impact of documentation in the software life cycle; (ii) studies describing developers' issues and concerns when dealing with software documentation; (iii) studies investigating the quality attributes required in documentation artifacts; (iv) studies providing guidelines and recommendations on how to write and maintain documentation; and (v) studies proposing frameworks and tools for assessing developers' concerns in this context."}},{"_id":"5eb234b5deb70a6af225f9a4","documentRepoId":"5eb233e3deb70a6af2233f52","documentRepoName":"research-emadpres-icse2020","fkglDelta":-3.492174080458394,"freDelta":4.872496857717408,"from":{"commitAuthorEmail":"lmorenoc@colostate.edu","commitId":"5eb233fcdeb70a6af2238100","readability":{"daleChallScore":12.13289534583064,"fleschKincaidGradeLevel":21.65769877181642,"fleschReadingEase":-3.980135746606294,"papersDomainScore":7.917465481577247},"text":"Although previous studies such as have investigated documentation issues and documentation types, there is still a gap when determining which are the more relevant ones --- both issues and documentation types --- for practitioners and their rationale. Some of previous studies are focused on the issues experienced with specific types of documentation, or only during a certain development phase; in other cases, the purpose of the study was not to find the most relevant issues but to be comprehensive when reporting all the documentations issues experienced by developers; and while there are studies reporting the usefulness of certain types of documentation based on studies with developers, those studies involved a small sample of participants, doesn't take practitioners' perspective into account, covered few documentation types or quality attributes, or focused on listing documentation preferences of developers during a certain development phase and did not provide rationale for the preferences. In this study we address those limitations of previous studies by analyzing what are the most relevant documentation issues and the most useful documentation types for developers, while trying to be comprehensive in terms of the issues, documentation types, and developers activities. We not only report the issues and documentation types, but also the developers reasons for their choices. Besides, we also present the common solutions that practitioners adopt when dealing with each documentation issue."},"to":{"commitAuthorEmail":"lmorenoc@colostate.edu","commitId":"5eb233fddeb70a6af22383bd","readability":{"daleChallScore":12.43843086419753,"fleschKincaidGradeLevel":18.165524691358026,"fleschReadingEase":0.8923611111111143,"papersDomainScore":7.370035802469136},"text":"Finally, a number of studies exploited a mining-based strategy for identifying documentation issues discussed by practitioners, by developers or by application users. In the most recent one, Aghajani et al. presented an extensive taxonomy of 162 types of issues faced by developers and users of software documentation, defined through the manual analysis of 878 documentation-related artifacts from four different sources (e.g., Stack Overflow discussions, pull requests). We start from the work by Aghajani et al. to assess the relevance of the documentation issues presented in their taxonomy, something completely neglected in their work. In other words, while Aghajani et al. main target was the definition of a comprehensive taxonomy of documentation issues, our goal is to understand whether (and which of) those issues are relevant for practitioners. As compared to previous work looking at documentation issues from the practitioners' perspective, while they focused on a specific type of documentation (i.e., API documentation), we consider a wide set of 51 documentation issues affecting several types of documentation."}},{"_id":"5eb234c6deb70a6af225fee2","documentRepoId":"5eb233e5deb70a6af2233f59","documentRepoName":"research-emadpres-icse2019","fkglDelta":-6.190591397849463,"freDelta":13.21411290322581,"from":{"commitAuthorEmail":"lmorenoc@colostate.edu","commitId":"5eb2343ddeb70a6af224b835","readability":{"daleChallScore":13.692924742268042,"fleschKincaidGradeLevel":26.925,"fleschReadingEase":-11.592499999999973,"papersDomainScore":10.762821649484536},"text":"Referring to deprecated information is also one of the main reasons for up-to-dateness issues, and can affect several types of documentation in different ways: It includes having deprecated information in the project's website (e.g.,**\"homepage recommends deprecated commands\"), outdated copyright information and version numbers in the code base, as well as outdated references (e.g., links to old versions of the system in the documentation), which was the most prevalent issue within this category. For example, one user reported that \"the example linked in the documentation is using the 3.x version of the API, and that may be confusing to readers\"."},"to":{"commitAuthorEmail":"lmorenoc@colostate.edu","commitId":"5eb2343edeb70a6af224b919","readability":{"daleChallScore":12.81442258064516,"fleschKincaidGradeLevel":20.734408602150538,"fleschReadingEase":1.621612903225838,"papersDomainScore":9.758293548387096},"text":"Referring to deprecated information is another reason for up-to-dateness issues and can affect several types of documentation in different ways. It includes having deprecated information in the project's website (e.g.,**\"homepage recommends deprecated commands\"), outdated copyright information and version numbers in the code base, as well as outdated references (e.g., links to old versions of the system in the documentation), which was the most prevalent issue within this category. For example, one user reported that \"the example linked in the documentation is using the 3.x version of the API, and that may be confusing to readers\"."}},{"_id":"5eb234c6deb70a6af225fed1","documentRepoId":"5eb233e5deb70a6af2233f59","documentRepoName":"research-emadpres-icse2019","fkglDelta":-17.794746376811595,"freDelta":52.179311594202886,"from":{"commitAuthorEmail":"lmorenoc@colostate.edu","commitId":"5eb23452deb70a6af224eb1f","readability":{"daleChallScore":15.068320289855073,"fleschKincaidGradeLevel":37.8272463768116,"fleschReadingEase":-53.24347826086955,"papersDomainScore":10.949189855072463},"text":"On the other side, documentation has been analyzed with a diversity of empirical studies that (i) report evidence of its importance and impact in the software cycle development, (ii) describe problems developers face when dealing with it, (iii) list quality attributes required in software documentation, (iv) provide recommendations for constructing it (including standards) , or (v) propose frameworks and tools for evaluating documentation concerns such as cost, benefit and quality attributes of software documentation."},"to":{"commitAuthorEmail":"michele.lanza@usi.ch","commitId":"5eb23452deb70a6af224fe86","readability":{"daleChallScore":13.051541666666667,"fleschKincaidGradeLevel":20.032500000000006,"fleschReadingEase":-1.0641666666666652,"papersDomainScore":9.301416666666668},"text":"(Empirical) Studies. Software documentation has been analyzed in diverse empirical studies that (i) report evidence of its importance and impact in the software life cycle, (ii) describe problems that developers face when dealing with it, (iii) list quality attributes required in documentation, (iv) provide recommendations for constructing it (including standards), and (v) propose frameworks and tools for evaluating documentation concerns such as cost, benefit and quality attributes. Due to space limitations we summarize the closest ones to our study in Table [tab:related_SwTechDocWorks]."}},{"_id":"5eb234c6deb70a6af2261c0c","documentRepoId":"5eb233e5deb70a6af2233f59","documentRepoName":"research-emadpres-icse2019","fkglDelta":-5.97882352941177,"freDelta":10.805294117647009,"from":{"commitAuthorEmail":"olvegam@unillanos.edu.co","commitId":"5eb233efdeb70a6af2235219","readability":{"daleChallScore":13.682311764705881,"fleschKincaidGradeLevel":26.12882352941177,"fleschReadingEase":-31.71029411764701,"papersDomainScore":12.289076470588236},"text":"Common Solution: Writing script is the most adopted solution regarding the automatic documentation deployment, while regarding the missing features there was no common solution (if any) and individuals usually points to different possible alternatives (e.g.,)."},"to":{"commitAuthorEmail":"emad.aghajani@usi.ch","commitId":"5eb233f0deb70a6af2235577","readability":{"daleChallScore":13.311975,"fleschKincaidGradeLevel":20.15,"fleschReadingEase":-20.905,"papersDomainScore":11.338225},"text":"Common Solution: Writing script was the most adopted solution regarding the automatic documentation deployment. Concerning the missing features there was no specific solution and individuals usually were pointed to different possible alternatives (e.g.,)."}},{"_id":"5eb234c6deb70a6af2260571","documentRepoId":"5eb233e5deb70a6af2233f59","documentRepoName":"research-emadpres-icse2019","fkglDelta":-11.592816901408455,"freDelta":32.35320422535213,"from":{"commitAuthorEmail":"emad.aghajani@usi.ch","commitId":"5eb233fddeb70a6af2238317","readability":{"daleChallScore":13.47230625,"fleschKincaidGradeLevel":34.44500000000001,"fleschReadingEase":-37.89999999999998,"papersDomainScore":11.49855625},"text":"Example: We observed different causes of incompleteness such as missing explanation (e.g.,**\"is there any idea what \"frequently used\" might mean?\"), a component in a library (e.g.,**\"The documentation on [...] is missing information about the toolbar buttons\"), API behavior clarification (e.g.,**\"I think that we should add documentation ensuring that the user passes a tree with reset bounds\"), or compatibility information (e.g.,**\"Explicitly mention if clang 4.x, 5.x are supported\")."},"to":{"commitAuthorEmail":"emad.aghajani@usi.ch","commitId":"5eb233fedeb70a6af22384a6","readability":{"daleChallScore":12.069130985915493,"fleschKincaidGradeLevel":22.852183098591553,"fleschReadingEase":-5.546795774647848,"papersDomainScore":10.067581690140845},"text":"Completeness accounts for %53 of issues in this section. We observed different causes of incompleteness such as missing explanation (e.g.,**\"is there any idea what \"frequently used\" might mean?\"), a component in a library (e.g.,**\"The documentation on [...] is missing information about the toolbar buttons\"), API behavior clarification (e.g.,**\"I think that we should add documentation ensuring that the user passes a tree with reset bounds\"), or compatibility information (e.g.,**\"Explicitly mention if clang 4.x, 5.x are supported\")."}},{"_id":"5eb234c6deb70a6af225fe6f","documentRepoId":"5eb233e5deb70a6af2233f59","documentRepoName":"research-emadpres-icse2019","fkglDelta":-21.28574835424172,"freDelta":62.36550656233179,"from":{"commitAuthorEmail":"olvegam@unillanos.edu.co","commitId":"5eb233f3deb70a6af2235c0b","readability":{"daleChallScore":16.123902409638553,"fleschKincaidGradeLevel":43.36554216867471,"fleschReadingEase":-68.0148192771084,"papersDomainScore":13.460528915662652},"text":"Common Solution: Besides solutions such as updating doc along code changes, updating outdated documentation when reported (e.g., removing outdated links if the target no longer exists or removing description of upcoming features or updating source code to match documentation) and rewriting documentation for a major new version, we observed other preventative solutions (such as putting documentation up-to-dateness as one of the items in contribution todo-list or making javadoc update mandatory for pull request acceptance) and hot fixes (e.g.,putting notice about outdated part of documentation."},"to":{"commitAuthorEmail":"csaba.nagy@usi.ch","commitId":"5eb233f4deb70a6af2235f41","readability":{"daleChallScore":13.053841580756014,"fleschKincaidGradeLevel":22.07979381443299,"fleschReadingEase":-5.649312714776613,"papersDomainScore":10.449305498281788},"text":"Common Solution: Typical solutions were updating the documentation according to the code changes, or fixing outdated parts of it (e.g., removing outdated links if the target no longer exists, removing the description of upcoming features. In some cases, it was necessary to update the source code to match the documentation , or to rewrite the whole documentation for a major new version. Interestingly, we observed preventative solutions too, such as putting documentation up-to-dateness as one of the items in contribution todo-list or making javadoc update mandatory for pull request acceptance) and hotfixes (e.g.,putting notice about outdated part of documentation."}},{"_id":"5eb234c6deb70a6af22619d2","documentRepoId":"5eb233e5deb70a6af2233f59","documentRepoName":"research-emadpres-icse2019","fkglDelta":-1.2137058095764566,"freDelta":7.2598092868988715,"from":{"commitAuthorEmail":"gabriele.bavota@usi.ch","commitId":"5eb2341fdeb70a6af223e3cd","readability":{"daleChallScore":11.412286948853616,"fleschKincaidGradeLevel":18.63818342151676,"fleschReadingEase":2.6561111111111018,"papersDomainScore":8.878089417989418},"text":"Besides the information content of documentation, the way how it is presented determines many quality attributes. Inspecting 803 discussions, we grouped these into Maintainability, Readability, Usability, and Usefulness issues, however, there are many other types of issues mentioned in the literature (e.g., see Zhi et al.). As our analysis reveals, a major part of the reported issues was related to simple typos or grammatical mistakes, but these were not considered harmful. Serious problems were these which affected the usefulness or the usability of the documentation, particularly those arising from lousy information organization or affecting the findability of the information. It is an unfortunate situation when the data is there, but the user is not able to find it or understand it. A recommendation for  icon practitioners is to adopt standard solutions and organize the documentation following best practices. While research  icon on investigating users' behavior on what and how they search a piece of information in the documentation could help to refine these practices."},"to":{"commitAuthorEmail":"gabriele.bavota@usi.ch","commitId":"5eb23420deb70a6af223e6ff","readability":{"daleChallScore":11.578710945273631,"fleschKincaidGradeLevel":17.424477611940304,"fleschReadingEase":9.915920398009973,"papersDomainScore":7.2187855721393035},"text":"Figure [fig:taxonomy] shows the hierarchical taxonomy of the 167 documentation issue types we defined. They are grouped into four main categories: problems related to the information content of the documentation describe issues arising from \"what\" is written in the documentation; issues classified in the content (how) category, are still related to the content of the documentation, but in this case the focus is on \"how\" the content is written and organized; the process-related category groups together issues related to the documentation process; finally, tool-related matters originate from the usage of a documentation tool. For each of these three categories, we describe in a dedicated subsection representative examples of issues we identified, and at the end of each subsection, discuss implications for researchers (indicated with the  icon) and/or practitioners ( icon) derived from our findings."}},{"_id":"5eb234c6deb70a6af2260959","documentRepoId":"5eb233e5deb70a6af2233f59","documentRepoName":"research-emadpres-icse2019","fkglDelta":-14.980263157894736,"freDelta":42.39065789473682,"from":{"commitAuthorEmail":"emad.aghajani@usi.ch","commitId":"5eb23409deb70a6af223a652","readability":{"daleChallScore":12.204807692307693,"fleschKincaidGradeLevel":31.000000000000004,"fleschReadingEase":-11.419999999999987,"papersDomainScore":10.261423076923077},"text":"However, we found one case in Apache httpd documentation mailing list where the traceability information between translations of a document was still managed manually, e.g., by adding a line of comment at top of translations referring to original document and more particularly \"The whole point of the comment is to see which exact revisions of the original file you have to diff to see the changes.\"."},"to":{"commitAuthorEmail":"csaba.nagy@usi.ch","commitId":"5eb2340bdeb70a6af223a94a","readability":{"daleChallScore":10.590450877192982,"fleschKincaidGradeLevel":16.019736842105267,"fleschReadingEase":30.97065789473683,"papersDomainScore":9.482380701754385},"text":"Interestingly, in another thread of the Apache httpd mailing list they discuss an issue of harmful warning messages originating from meta-information they also use to enforce up-to-dateness of different translations. As they conclude, \"The whole point of the comment is to see which exact revisions of the original file you have to diff to see the changes.\"."}},{"_id":"5eb234c6deb70a6af2261837","documentRepoId":"5eb233e5deb70a6af2233f59","documentRepoName":"research-emadpres-icse2019","fkglDelta":6.439660633484163,"freDelta":-22.124219457013595,"from":{"commitAuthorEmail":"lmorenoc@colostate.edu","commitId":"5eb2344adeb70a6af224ca42","readability":{"daleChallScore":12.641496078431373,"fleschKincaidGradeLevel":19.805980392156865,"fleschReadingEase":-1.5180882352940728,"papersDomainScore":10.474241176470588},"text":"Interestingly, we observed that developers adopt preventative solutions to ensure the up-to-dateness of the project's documentation. For example, some projects have added documentation up-to-dateness as one of the items to check in the contribution to-do list, and others have pushed this forward by making Javadoc update mandatory for pull request acceptance."},"to":{"commitAuthorEmail":"gabriele.bavota@usi.ch","commitId":"5eb2344bdeb70a6af224cb2d","readability":{"daleChallScore":13.263464102564104,"fleschKincaidGradeLevel":26.245641025641028,"fleschReadingEase":-23.642307692307668,"papersDomainScore":11.643976923076922},"text":"Some developers adopt preventative solutions to ensure the documentation up-to-dateness, adding documentation up-to-dateness as one of the items to check in the contribution to-do list, or even pushing this forward by making Javadoc update mandatory for pull request acceptance."}},{"_id":"5eb234c6deb70a6af225fbb3","documentRepoId":"5eb233e5deb70a6af2233f59","documentRepoName":"research-emadpres-icse2019","fkglDelta":11.207702702702708,"freDelta":-32.263783783783765,"from":{"commitAuthorEmail":"olvegam@unillanos.edu.co","commitId":"5eb233f3deb70a6af2235c0b","readability":{"daleChallScore":12.08642972972973,"fleschKincaidGradeLevel":23.2372972972973,"fleschReadingEase":-5.636216216216212,"papersDomainScore":9.952645945945946},"text":"Example: The incompleteness could raise from different things such as missing explanation (e.g.,**\"is there any idea what \"frequently used\" might mean?\"), a component in a library (e.g.,**\"The documentation on [...] is missing information about the toolbar buttons\"), API behavior clarification (e.g.,**\"I think that we should add documentation ensuring that the user passes a tree with reset bounds\"), or compatibility information (e.g.,**\"Explicitly mention if clang 4.x, 5.x are supported\"). Fig 4.4 illustrate other type of missing information we observed."},"to":{"commitAuthorEmail":"csaba.nagy@usi.ch","commitId":"5eb233f4deb70a6af2235f41","readability":{"daleChallScore":13.47230625,"fleschKincaidGradeLevel":34.44500000000001,"fleschReadingEase":-37.89999999999998,"papersDomainScore":11.49855625},"text":"Example: We observed different causes of incompleteness such as missing explanation (e.g.,**\"is there any idea what \"frequently used\" might mean?\"), a component in a library (e.g.,**\"The documentation on [...] is missing information about the toolbar buttons\"), API behavior clarification (e.g.,**\"I think that we should add documentation ensuring that the user passes a tree with reset bounds\"), or compatibility information (e.g.,**\"Explicitly mention if clang 4.x, 5.x are supported\")."}},{"_id":"5eb234c6deb70a6af2260bfa","documentRepoId":"5eb233e5deb70a6af2233f59","documentRepoName":"research-emadpres-icse2019","fkglDelta":5.929240959541712,"freDelta":-22.917524167561766,"from":{"commitAuthorEmail":"csaba.nagy@usi.ch","commitId":"5eb233ffdeb70a6af223890c","readability":{"daleChallScore":12.723756140350877,"fleschKincaidGradeLevel":21.070350877192983,"fleschReadingEase":11.680789473684229,"papersDomainScore":9.538054385964912},"text":"Referring to deprecated information was another case of this issue which was fixed in a case when a user opened an issue and wrote \"Homepage recommends deprecated command\"). This category of issues also affects other types of information, such as copyright information, version numbers in the code base and even outdated references (22%) which was the most prevalent issue within current category. In one example the outdated link was updated after a user opened an issue and wrote \"the example linked in the documentation is using the 3.x version of the API, and that may be confusing to readers\", and in another example the outdated link was removed by developers since the target no longer existed."},"to":{"commitAuthorEmail":"gabriele.bavota@usi.ch","commitId":"5eb23400deb70a6af2238af3","readability":{"daleChallScore":13.639655102040816,"fleschKincaidGradeLevel":26.999591836734695,"fleschReadingEase":-11.236734693877537,"papersDomainScore":10.739451020408163},"text":"Referring to deprecated information is also one of the main reasons for up-to-dateness issues, and can affect different types of documentation in different ways: It includes having deprecated information in the project's website (e.g.,\"Homepage recommends deprecated command\"), to outdated copyright information and version numbers in the code base, as well as outdated references (e.g., links to old versions of the system in the documentation), which was the most prevalent issue within this category. For example, one user reported that \"the example linked in the documentation is using the 3.x version of the API, and that may be confusing to readers\"."}}]